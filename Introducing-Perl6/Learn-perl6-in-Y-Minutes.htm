<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!-->
<html class="no-js"><!--<![endif]--><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta http-equiv="Content-Language" content="en-us">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn perl6 in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="Learn-perl6-in-Y-Minutes_fichiers/index.css">

        <link rel="canonical" href="https://learnxinyminutes.com/docs/perl6/">
        <script src="Learn-perl6-in-Y-Minutes_fichiers/ga.js"></script><script>
            function set_theme(theme) {
                var el = document.getElementsByTagName("html")[0];

                if (theme === "dark" ) {
                    el.className = "dark";
                } else {
                    el.className = "light";
                }

                localStorage.setItem("lxiym_theme", theme);
            }

            var theme = localStorage.getItem("lxiym_theme");
            if (theme) {
                set_theme(theme);
            }
        </script>
    <style id="style-1-cropbar-clipper">/* Copyright 2014 Evernote Corporation. All rights reserved. */
.en-markup-crop-options {
    top: 18px !important;
    left: 50% !important;
    margin-left: -100px !important;
    width: 200px !important;
    border: 2px rgba(255,255,255,.38) solid !important;
    border-radius: 4px !important;
}

.en-markup-crop-options div div:first-of-type {
    margin-left: 0px !important;
}
</style></head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fperl6%2F&amp;text=Learn+X+in+Y+minutes%2C+where+X%3Dperl6">
        Share this page
      </a></span>

      <span class="st_facebook_large" displaytext="Facebook"></span>
      <span class="st_twitter_large" displaytext="Tweet"></span>
  </div>
  <div class="theme-choice">
    <label id="theme-label">Select theme:</label>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('light');">light</button>
    <button type="button" aria-labelledby="theme-label" onclick="set_theme('dark');">dark</button>
  </div>
  <h1><a href="https://learnxinyminutes.com/">Learn X in Y minutes</a></h1>
  <h2>Where X=perl6</h2>
    <p class="filelink">
    Get the code:
    <a href="https://learnxinyminutes.com/docs/files/learnperl6.p6">learnperl6.p6</a>
    </p>
  <div id="doc">
    <p>Perl 6 is a highly capable, feature-rich programming language made for at
least the next hundred years.</p>

<p>The primary Perl 6 compiler is called <a href="http://rakudo.org/">Rakudo</a>, which runs on
the JVM and <a href="http://moarvm.com/">the MoarVM</a>.</p>

<p>Meta-note: double pound signs (<code>##</code>) are used to indicate paragraphs,
while single pound signs (<code>#</code>) indicate notes.</p>

<p><code>#=&gt;</code> represents the output of a command.</p>
<div class="highlight"><pre><span></span><span class="c1"># Single line comments start with a pound sign.</span>

<span class="cm">#`( Multiline comments use #` and a quoting construct.</span>
<span class="cm">  (), [], {}, 「」, etc, will work.</span>
<span class="cm">)</span>

<span class="c1"># Use the same syntax for multiline comments to embed comments.</span>
<span class="k">for</span> <span class="cm">#`(each element in)</span> <span class="nv">@array</span> {
    <span class="n">put</span> <span class="cm">#`(or print element)</span> <span class="nv">$_</span> <span class="cm">#`(with newline)</span>;
}
</pre></div>
<h2>Variables</h2>
<div class="highlight"><pre><span></span><span class="c1">## In Perl 6, you declare a lexical variable using the `my` keyword:</span>
<span class="k">my</span> <span class="nv">$variable</span>;
<span class="c1">## Perl 6 has 3 basic types of variables: scalars, arrays, and hashes.</span>
</pre></div>
<h3>Scalars</h3>
<div class="highlight"><pre><span></span><span class="c1"># Scalars represent a single value. They start with the `$` sigil:</span>
<span class="k">my</span> <span class="nv">$str</span> = <span class="s">'String'</span>;

<span class="c1"># Double quotes allow for interpolation (which we'll see later):</span>
<span class="k">my</span> <span class="nv">$str2</span> = <span class="s">"String"</span>;

<span class="c1">## Variable names can contain but not end with simple quotes and dashes,</span>
<span class="c1">## and can contain (and end with) underscores:</span>
<span class="k">my</span> <span class="nv">$person's-belongings</span> = <span class="s">'towel'</span>; <span class="c1"># this works!</span>

<span class="k">my</span> <span class="nv">$bool</span> = <span class="nb">True</span>;             <span class="c1"># `True` and `False` are Perl 6's boolean values.</span>
<span class="k">my</span> <span class="nv">$inverse</span> = !<span class="nv">$bool</span>;        <span class="c1"># Invert a bool with the prefix `!` operator.</span>
<span class="k">my</span> <span class="nv">$forced-bool</span> = <span class="o">so</span> <span class="nv">$str</span>;   <span class="c1"># And you can use the prefix `so` operator</span>
<span class="nv">$forced-bool</span> = ?<span class="nv">$str</span>;        <span class="c1"># to turn its operand into a Bool. Or use `?`.</span>
</pre></div>
<h3>Arrays and Lists</h3>
<div class="highlight"><pre><span></span><span class="c1">## Arrays represent multiple values. An array variable starts with the `@`</span>
<span class="c1">## sigil. Unlike lists, from which arrays inherit, arrays are mutable.</span>

<span class="k">my</span> <span class="nv">@array</span> = <span class="s">'a'</span>, <span class="s">'b'</span>, <span class="s">'c'</span>;
<span class="c1"># equivalent to:</span>
<span class="k">my</span> <span class="nv">@letters</span> = <span class="s">&lt;a b c&gt;</span>; <span class="c1"># array of words, delimited by space.</span>
                       <span class="c1"># Similar to perl5's qw, or Ruby's %w.</span>
<span class="nv">@array</span> = <span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">3</span>;

<span class="nb">say</span> <span class="nv">@array</span>[<span class="mi">2</span>];         <span class="c1"># Array indices start at 0. Here the third element</span>
                       <span class="c1"># is being accessed.</span>

<span class="nb">say</span> <span class="s">"Interpolate an array using []: @array[]"</span>;
<span class="c1">#=&gt; Interpolate an array using []: 1 2 3</span>

<span class="nv">@array</span>[<span class="mi">0</span>]    = -<span class="mi">1</span>;     <span class="c1"># Assigning a new value to an array index</span>
<span class="nv">@array</span>[<span class="mi">0</span>, <span class="mi">1</span>] = <span class="mi">5</span>, <span class="mi">6</span>;   <span class="c1"># Assigning multiple values</span>

<span class="k">my</span> <span class="nv">@keys</span> = <span class="mi">0</span>, <span class="mi">2</span>;
<span class="nv">@array</span>[<span class="nv">@keys</span>] = <span class="nv">@letters</span>; <span class="c1"># Assignment using an array containing index values</span>
<span class="nb">say</span> <span class="nv">@array</span>;               <span class="c1">#=&gt; a 6 b</span>
</pre></div>
<h3>Hashes, or key-value Pairs.</h3>
<div class="highlight"><pre><span></span><span class="c1">## Hashes are pairs of keys and values. You can construct a `Pair` object</span>
<span class="c1">## using the syntax `Key =&gt; Value`. Hash tables are very fast for lookup,</span>
<span class="c1">## and are stored unordered. Keep in mind that keys get "flattened" in hash</span>
<span class="c1">## context, and any duplicated keys are deduplicated.</span>
<span class="k">my</span> <span class="nv">%hash</span> = <span class="s">'a'</span> =&gt; <span class="mi">1</span>, <span class="s">'b'</span> =&gt; <span class="mi">2</span>;

<span class="nv">%hash</span> = <span class="n">a</span> =&gt; <span class="mi">1</span>,  <span class="c1"># keys get auto-quoted when =&gt; (fat comma) is used.</span>
        <span class="n">b</span> =&gt; <span class="mi">2</span>,  <span class="c1"># Trailing commas are okay.</span>
;

<span class="c1">## Even though hashes are internally stored differently than arrays,</span>
<span class="c1">## Perl 6 allows you to easily create a hash from an even numbered array:</span>
<span class="nv">%hash</span> = <span class="s">&lt;key1 value1 key2 value2&gt;</span>;          <span class="c1"># Or:</span>
<span class="nv">%hash</span> = <span class="s">"key1"</span>, <span class="s">"value1"</span>, <span class="s">"key2"</span>, <span class="s">"value2"</span>;

<span class="nv">%hash</span> = <span class="n">key1</span> =&gt; <span class="s">'value1'</span>, <span class="n">key2</span> =&gt; <span class="s">'value2'</span>; <span class="c1"># same result as above</span>

<span class="c1">## You can also use the "colon pair" syntax. This syntax is especially</span>
<span class="c1">## handy for named parameters that you'll see later.</span>
<span class="nv">%hash</span> = :<span class="n">w</span>(<span class="mi">1</span>),    <span class="c1"># equivalent to `w =&gt; 1`</span>
        :<span class="n">truey</span>,   <span class="c1"># equivalent to `:truey(True)` or `truey =&gt; True`</span>
        :!<span class="n">falsey</span>, <span class="c1"># equivalent to `:falsey(False)` or `falsey =&gt; False`</span>
;
<span class="c1">## The :truey and :!falsey constructs are known as the</span>
<span class="c1">## `True` and `False` shortcuts respectively.</span>

<span class="nb">say</span> <span class="nv">%hash</span>{<span class="s">'key1'</span>};   <span class="c1"># You can use {} to get the value from a key.</span>
<span class="nb">say</span> <span class="nv">%hash&lt;key2&gt;</span>;     <span class="c1"># If it's a string without spaces, you can actually use</span>
                     <span class="c1"># &lt;&gt; (quote-words operator). `{key1}` doesn't work,</span>
                     <span class="c1"># as Perl6 doesn't have barewords.</span>
</pre></div>
<h2>Subs</h2>
<div class="highlight"><pre><span></span><span class="c1">## Subroutines, or functions as most other languages call them, are</span>
<span class="c1">## created with the `sub` keyword.</span>
<span class="k">sub</span> <span class="n">say-hello</span> { <span class="nb">say</span> <span class="s">"Hello, world"</span> }

<span class="c1">## You can provide (typed) arguments. If specified, the type will be checked</span>
<span class="c1">## at compile-time if possible, otherwise at runtime.</span>
<span class="k">sub</span> <span class="n">say-hello-to</span>( <span class="nb">Str</span> <span class="nv">$name</span> ) {
    <span class="nb">say</span> <span class="s">"Hello, $name !"</span>;
}

<span class="c1">## A sub returns the last value of the block. Similarly, the semicolon in</span>
<span class="c1">## the last can be omitted.</span>
<span class="k">sub</span> <span class="n">return-value</span> { <span class="mi">5</span> }
<span class="nb">say</span> <span class="n">return-value</span>;      <span class="c1"># prints 5</span>

<span class="k">sub</span> <span class="n">return-empty</span> { }
<span class="nb">say</span> <span class="n">return-empty</span>;      <span class="c1"># prints Nil</span>

<span class="c1">## Some control flow structures produce a value, like `if`:</span>
<span class="k">sub</span> <span class="n">return-if</span> {
    <span class="k">if</span> <span class="nb">True</span> { <span class="s">"Truthy"</span> }
}
<span class="nb">say</span> <span class="n">return-if</span>;         <span class="c1"># prints Truthy</span>

<span class="c1">## Some don't, like `for`:</span>
<span class="k">sub</span> <span class="n">return-for</span> {
    <span class="k">for</span> <span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">3</span> { <span class="s">'Hi'</span> }
}
<span class="nb">say</span> <span class="n">return-for</span>;        <span class="c1"># prints Nil</span>

<span class="c1">## Positional arguments are required by default. To make them optional, use</span>
<span class="c1">## the `?` after the parameters' names.</span>
<span class="k">sub</span> <span class="n">with-optional</span>( <span class="nv">$arg</span>? ) {
  <span class="c1"># This sub returns `(Any)` (Perl's null-like value) if</span>
  <span class="c1"># no argument is passed. Otherwise, it returns its argument.</span>
  <span class="nv">$arg</span>;
}
<span class="n">with-optional</span>;     <span class="c1"># returns Any</span>
<span class="n">with-optional</span>();   <span class="c1"># returns Any</span>
<span class="n">with-optional</span>(<span class="mi">1</span>);  <span class="c1"># returns 1</span>

<span class="c1">## You can also give them a default value when they're not passed.</span>
<span class="c1">## Required parameters must come before optional ones.</span>
<span class="k">sub</span> <span class="n">greeting</span>( <span class="nv">$name</span>, <span class="nv">$type</span> = <span class="s">"Hello"</span> ) {
  <span class="nb">say</span> <span class="s">"$type, $name!"</span>;
}

<span class="n">greeting</span>(<span class="s">"Althea"</span>);                 <span class="c1">#=&gt; Hello, Althea!</span>
<span class="n">greeting</span>(<span class="s">"Arthur"</span>, <span class="s">"Good morning"</span>); <span class="c1">#=&gt; Good morning, Arthur!</span>

<span class="c1">## You can also, by using a syntax akin to the one of hashes</span>
<span class="c1">## (yay unified syntax !), pass *named* arguments to a `sub`. They're</span>
<span class="c1">## optional, and will default to "Any".</span>
<span class="k">sub</span> <span class="n">with-named</span>( <span class="nv">$normal-arg</span>, :<span class="nv">$named</span> ) {
    <span class="nb">say</span> <span class="nv">$normal-arg</span> + <span class="nv">$named</span>;
}
<span class="n">with-named</span>(<span class="mi">1</span>, <span class="n">named</span> =&gt; <span class="mi">6</span>); <span class="c1">#=&gt; 7</span>

<span class="c1">## There's one gotcha to be aware of, here: If you quote your key, Perl 6</span>
<span class="c1">## won't be able to see it at compile time, and you'll have a single `Pair`</span>
<span class="c1">## object as a positional parameter, which means</span>
<span class="c1">## `with-named(1, 'named' =&gt; 6);` fails.</span>

<span class="n">with-named</span>(<span class="mi">2</span>, :<span class="n">named</span>(<span class="mi">5</span>));  <span class="c1">#=&gt; 7</span>

<span class="c1">## To make a named argument mandatory, you can append `!` to the parameter,</span>
<span class="c1">## which is the inverse of `?`:</span>
<span class="k">sub</span> <span class="n">with-mandatory-named</span>( :<span class="nv">$str</span>! )  {
    <span class="nb">say</span> <span class="s">"$str!"</span>;
}
<span class="n">with-mandatory-named</span>(<span class="n">str</span> =&gt; <span class="s">"My String"</span>); <span class="c1">#=&gt; My String!</span>
<span class="n">with-mandatory-named</span>;   <span class="c1"># runtime error:"Required named parameter not passed"</span>
<span class="n">with-mandatory-named</span>(<span class="mi">3</span>);<span class="c1"># runtime error:"Too many positional parameters passed"</span>

<span class="c1">## If a sub takes a named boolean argument...</span>
<span class="k">sub</span> <span class="n">takes-a-bool</span>( <span class="nv">$name</span>, :<span class="nv">$bool</span> ) {
    <span class="nb">say</span> <span class="s">"$name takes $bool"</span>;
}
<span class="c1">## ... you can use the same "short boolean" hash syntax:</span>
<span class="n">takes-a-bool</span>(<span class="s">'config'</span>, :<span class="n">bool</span>);  <span class="c1">#=&gt; config takes True</span>
<span class="n">takes-a-bool</span>(<span class="s">'config'</span>, :!<span class="nb">bool</span>); <span class="c1">#=&gt; config takes False</span>

<span class="c1">## You can also provide your named arguments with default values:</span>
<span class="k">sub</span> <span class="n">named-def</span>( :<span class="nv">$def</span> = <span class="mi">5</span> ) {
    <span class="nb">say</span> <span class="nv">$def</span>;
}
<span class="n">named-def</span>;            <span class="c1">#=&gt; 5</span>
<span class="n">named-def</span>(<span class="n">def</span> =&gt; <span class="mi">15</span>); <span class="c1">#=&gt; 15</span>

<span class="c1">## Since you can omit parenthesis to call a function with no arguments,</span>
<span class="c1">## you need `&amp;` in the name to store `say-hello` in a variable. This means</span>
<span class="c1">## `&amp;say-hello` is a code object and not a subroutine call.</span>
<span class="k">my</span> <span class="nv">&amp;s</span> = <span class="nv">&amp;say-hello</span>;
<span class="k">my</span> <span class="nv">&amp;other-s</span> = <span class="k">sub</span> { <span class="nb">say</span> <span class="s">"Anonymous function!"</span> }

<span class="c1">## A sub can have a "slurpy" parameter, or "doesn't-matter-how-many". For</span>
<span class="c1">## this, you must use `*@` (slurpy) which will "take everything else". You can</span>
<span class="c1">## have as many parameters *before* a slurpy one, but not *after*.</span>
<span class="k">sub</span> <span class="n">as-many</span>(<span class="nv">$head</span>, *<span class="nv">@rest</span>) {
    <span class="nb">say</span> <span class="nv">@rest</span>.<span class="nb">join</span>(<span class="s">' / '</span>) ~ <span class="s">" !"</span>;
}
<span class="nb">say</span> <span class="n">as-many</span>(<span class="s">'Happy'</span>, <span class="s">'Happy'</span>, <span class="s">'Birthday'</span>);<span class="c1">#=&gt; Happy / Birthday !</span>
                                          <span class="c1"># Note that the splat (the *) did not</span>
                                          <span class="c1"># consume the parameter before it.</span>

<span class="c1">## You can call a function with an array using the "argument list flattening"</span>
<span class="c1">## operator `|` (it's not actually the only role of this operator,</span>
<span class="c1">## but it's one of them).</span>
<span class="k">sub</span> <span class="n">concat3</span>(<span class="nv">$a</span>, <span class="nv">$b</span>, <span class="nv">$c</span>) {
    <span class="nb">say</span> <span class="s">"$a, $b, $c"</span>;
}
<span class="n">concat3</span>(|<span class="nv">@array</span>); <span class="c1">#=&gt; a, b, c</span>
                  <span class="c1"># `@array` got "flattened" as a part of the argument list</span>
</pre></div>
<h2>Containers</h2>
<div class="highlight"><pre><span></span><span class="c1">## In Perl 6, values are actually stored in "containers". The assignment</span>
<span class="c1">## operator asks the container on the left to store the value on its right.</span>
<span class="c1">## When passed around, containers are marked as immutable which means that,</span>
<span class="c1">## in a function, you'll get an error if you try to mutate one of your</span>
<span class="c1">## arguments. If you really need to, you can ask for a mutable container by</span>
<span class="c1">## using the `is rw` trait:</span>
<span class="k">sub</span> <span class="n">mutate</span>( <span class="nv">$n</span> <span class="k">is</span> <span class="k">rw</span> ) {
    <span class="nv">$n</span>++;
}

<span class="k">my</span> <span class="nv">$m</span> = <span class="mi">42</span>;
<span class="n">mutate</span> <span class="nv">$m</span>; <span class="c1">#=&gt; 43</span>
<span class="nb">say</span> <span class="nv">$m</span>;    <span class="c1">#=&gt; 43</span>

<span class="c1">## This works because we are passing the container $m to the `mutate` sub.</span>
<span class="c1">## If we try to just pass a number instead of passing a variable it won't work</span>
<span class="c1">## because there is no container being passed and integers are immutable by</span>
<span class="c1">## themselves:</span>

<span class="n">mutate</span> <span class="mi">42</span>; <span class="c1"># Parameter '$n' expected a writable container, but got Int value</span>

<span class="c1">## Similar error would be obtained, if a bound variable is passed to</span>
<span class="c1">## to the subroutine:</span>

<span class="k">my</span> <span class="nv">$v</span> := <span class="mi">50</span>; <span class="c1"># binding 50 to the variable $v</span>
<span class="n">mutate</span> <span class="nv">$v</span>; <span class="c1"># Parameter '$n' expected a writable container, but got Int value</span>

<span class="c1">## If what you want is a copy instead, use the `is copy` trait which will</span>
<span class="c1">## cause the argument to be copied and allow you to modify the argument</span>
<span class="c1">## inside the routine.</span>

<span class="c1">## A sub itself returns a container, which means it can be marked as rw:</span>
<span class="k">my</span> <span class="nv">$x</span> = <span class="mi">42</span>;
<span class="k">sub</span> <span class="o">x-</span><span class="n">store</span>() <span class="k">is</span> <span class="k">rw</span> { <span class="nv">$x</span> }
<span class="o">x-</span><span class="n">store</span>() = <span class="mi">52</span>; <span class="c1"># in this case, the parentheses are mandatory</span>
                <span class="c1"># (else Perl 6 thinks `x-store` is an identifier)</span>
<span class="nb">say</span> <span class="nv">$x</span>;         <span class="c1">#=&gt; 52</span>
</pre></div>
<h2>Control Flow Structures</h2>

<h3>Conditionals</h3>
<div class="highlight"><pre><span></span><span class="c1">## - `if`</span>
<span class="c1">## Before talking about `if`, we need to know which values are "Truthy"</span>
<span class="c1">## (represent True), and which are "Falsey" (represent False). Only these</span>
<span class="c1">## values are Falsey: 0, (), {}, "", Nil, A type (like `Str` or `Int`) and</span>
<span class="c1">## of course False itself. Any other value is Truthy.</span>
<span class="k">if</span> <span class="nb">True</span> {
    <span class="nb">say</span> <span class="s">"It's true!"</span>;
}

<span class="k">unless</span> <span class="nb">False</span> {
    <span class="nb">say</span> <span class="s">"It's not false!"</span>;
}

<span class="c1">## As you can see, you don't need parentheses around conditions. However, you</span>
<span class="c1">## do need the curly braces around the "body" block. For example,</span>
<span class="c1">## `if (true) say;` doesn't work.</span>

<span class="c1">## You can also use their statement modifier (postfix) versions:</span>
<span class="nb">say</span> <span class="s">"Quite truthy"</span> <span class="k">if</span> <span class="nb">True</span>;      <span class="c1">#=&gt; Quite truthy</span>
<span class="nb">say</span> <span class="s">"Quite falsey"</span> <span class="k">unless</span> <span class="nb">False</span>; <span class="c1">#=&gt; Quite falsey</span>

<span class="c1">## - Ternary operator, "x ?? y !! z"</span>
<span class="c1">## This returns $value-if-true if the condition is true and $value-if-false</span>
<span class="c1">## if it is false.</span>
<span class="c1">## my $result = condition ?? $value-if-true !! $value-if-false;</span>

<span class="k">my</span> <span class="nv">$age</span> = <span class="mi">30</span>;
<span class="nb">say</span> <span class="nv">$age</span> &gt; <span class="mi">18</span> ?? <span class="s">"You are an adult"</span> !! <span class="s">"You are under 18"</span>;
<span class="c1">#=&gt; You are an adult</span>
</pre></div>
<h3>given/when, or Perl 6’s switch construct</h3>
<div class="highlight"><pre><span></span><span class="c1">## `given...when` looks like other languages' `switch`, but is much more</span>
<span class="c1">## powerful thanks to smart matching and Perl 6's "topic variable", $_.</span>
<span class="c1">##</span>
<span class="c1">## The topic variable $_ contains the default argument of a block, a loop's</span>
<span class="c1">## current iteration (unless explicitly named), etc.</span>
<span class="c1">##</span>
<span class="c1">## `given` simply puts its argument into `$_` (like a block would do),</span>
<span class="c1">##  and `when` compares it using the "smart matching" (`~~`) operator.</span>
<span class="c1">##</span>
<span class="c1">## Since other Perl 6 constructs use this variable (as said before, like `for`,</span>
<span class="c1">## blocks, etc), this means the powerful `when` is not only applicable along</span>
<span class="c1">## with a `given`, but instead anywhere a `$_` exists.</span>

<span class="k">given</span> <span class="s">"foo bar"</span> {
    <span class="nb">say</span> <span class="nv">$_</span>;            <span class="c1">#=&gt; foo bar</span>
    <span class="k">when</span> /<span class="n">foo</span>/ {       <span class="c1"># Don't worry about smart matching yet. Just know</span>
        <span class="nb">say</span> <span class="s">"Yay !"</span>;   <span class="c1"># `when` uses it. This is equivalent to `if $_ ~~ /foo/`.</span>

    }
    <span class="k">when</span> <span class="nv">$_</span>.<span class="nb">chars</span> &gt; <span class="mi">50</span> { <span class="c1"># smart matching anything with True is True,</span>
                         <span class="c1"># i.e. (`$a ~~ True`)</span>
                         <span class="c1"># so you can also put "normal" conditionals.</span>
                         <span class="c1"># This `when` is equivalent to this `if`:</span>
                         <span class="c1"># `if $_ ~~ ($_.chars &gt; 50) {...}`</span>
                         <span class="c1"># which means: `if $_.chars &gt; 50 {...}`</span>
        <span class="nb">say</span> <span class="s">"Quite a long string !"</span>;
    }
    <span class="k">default</span> { <span class="c1"># same as `when *` (using the Whatever Star)</span>
        <span class="nb">say</span> <span class="s">"Something else"</span>
    }
}
</pre></div>
<h3>Looping constructs</h3>
<div class="highlight"><pre><span></span><span class="c1">## - `loop` is an infinite loop if you don't pass it arguments, but can also</span>
<span class="c1">## be a C-style `for` loop:</span>
<span class="k">loop</span> {
    <span class="nb">say</span> <span class="s">"This is an infinite loop !"</span>;
    <span class="k">last</span>;                             <span class="c1"># last breaks out of the loop, like</span>
                                      <span class="c1"># the `break` keyword in other languages</span>
}

<span class="k">loop</span> (<span class="k">my</span> <span class="nv">$i</span> = <span class="mi">0</span>; <span class="nv">$i</span> &lt; <span class="mi">5</span>; <span class="nv">$i</span>++) {
    <span class="k">next</span> <span class="k">if</span> <span class="nv">$i</span> == <span class="mi">3</span>; <span class="c1"># `next` skips to the next iteration, like `continue`</span>
                   <span class="c1"># in other languages. Note that you can also use postfix</span>
                   <span class="c1"># conditionals, loops, etc.</span>
    <span class="nb">say</span> <span class="s">"This is a C-style for loop!"</span>;
}

<span class="c1">## - `for` - Iterating through an array</span>

<span class="k">my</span> <span class="nv">@array</span> = <span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">6</span>, <span class="mi">7</span>, <span class="mi">3</span>;

<span class="c1">## Accessing the array's elements with the topic variable $_.</span>
<span class="k">for</span> <span class="nv">@array</span> {
    <span class="nb">say</span> <span class="s">"I've got $_ !"</span>;
}

<span class="c1">## Accessing the array's elements with a "pointy block", `-&gt;`.</span>
<span class="c1">## Here each element is read-only.</span>
<span class="k">for</span> <span class="nv">@array</span> -&gt; <span class="nv">$variable</span> {
    <span class="nb">say</span> <span class="s">"I've got $variable !"</span>;
}

<span class="c1">## Accessing the array's elements with a "doubly pointy block", `&lt;-&gt;`.</span>
<span class="c1">## Here each element is read-write so mutating `$variable` mutates</span>
<span class="c1">## that element in the array.</span>
<span class="k">for</span> <span class="nv">@array</span> <span class="s">&lt;-&gt; $variable {</span>
<span class="s">    say "I've got $variable !";</span>
<span class="s">}</span>

<span class="s">## As we saw with given, a for loop's default "current iteration" variable</span>
<span class="s">## is `$_`. That means you can use `when` in a `for`loop just like you were</span>
<span class="s">## able to in a `given`.</span>
<span class="s">for @array {</span>
<span class="s">    say "I've got $_";</span>

<span class="s">    .say;   # This is also allowed. A dot call with no "topic" (receiver)</span>
<span class="s">            # is sent to `$_` by default</span>
<span class="s">    $_.say; # This is equivalent to the above statement.</span>
<span class="s">}</span>

<span class="s">for @array {</span>
<span class="s">    # You can...</span>
<span class="s">    next if $_ == 3; # Skip to the next iteration (`continue` in C-like lang.)</span>
<span class="s">    redo if $_ == 4; # Re-do iteration, keeping the same topic variable (`$_`)</span>
<span class="s">    last if $_ == 5; # Or break out of loop (like `break` in C-like lang.)</span>
<span class="s">}</span>

<span class="s">## The "pointy block" syntax isn't specific to the `for` loop. It's just a way</span>
<span class="s">## to express a block in Perl 6.</span>
<span class="s">sub long-computation { "Finding factors of large primes" }</span>
<span class="s">if long-computation() -&gt;</span> <span class="nv">$result</span> {
    <span class="nb">say</span> <span class="s">"The result is $result."</span>;
}
</pre></div>
<h2>Operators</h2>
<div class="highlight"><pre><span></span><span class="c1">## Since Perl languages are very much operator-based languages, Perl 6</span>
<span class="c1">## operators are actually just funny-looking subroutines, in syntactic</span>
<span class="c1">## categories, like infix:&lt;+&gt; (addition) or prefix:&lt;!&gt; (bool not).</span>

<span class="c1">## The categories are:</span>
<span class="c1">## - "prefix": before (like `!` in `!True`).</span>
<span class="c1">## - "postfix": after (like `++` in `$a++`).</span>
<span class="c1">## - "infix": in between (like `*` in `4 * 3`).</span>
<span class="c1">## - "circumfix": around (like `[`-`]` in `[1, 2]`).</span>
<span class="c1">## - "post-circumfix": around, after another term (like `{`-`}` in</span>
<span class="c1">##                    `%hash{'key'}`)</span>

<span class="c1">## The associativity and precedence list are explained below.</span>

<span class="c1">## Alright, you're set to go!</span>

<span class="c1">## Equality Checking</span>
<span class="c1">##------------------</span>

<span class="c1">## - `==` is numeric comparison</span>
<span class="mi">3</span> == <span class="mi">4</span>; <span class="c1">#=&gt; False</span>
<span class="mi">3</span> != <span class="mi">4</span>; <span class="c1">#=&gt; True</span>

<span class="c1">## - `eq` is string comparison</span>
<span class="s">'a'</span> <span class="o">eq</span> <span class="s">'b'</span>;  <span class="c1">#=&gt; False</span>
<span class="s">'a'</span> <span class="o">ne</span> <span class="s">'b'</span>;  <span class="c1">#=&gt; True, not equal</span>
<span class="s">'a'</span> !<span class="o">eq</span> <span class="s">'b'</span>; <span class="c1">#=&gt; True, same as above</span>

<span class="c1">## - `eqv` is canonical equivalence (or "deep equality")</span>
(<span class="mi">1</span>, <span class="mi">2</span>) <span class="o">eqv</span> (<span class="mi">1</span>, <span class="mi">3</span>); <span class="c1">#=&gt; False</span>
(<span class="mi">1</span>, <span class="mi">2</span>) <span class="o">eqv</span> (<span class="mi">1</span>, <span class="mi">2</span>); <span class="c1">#=&gt; True</span>
<span class="nb">Int</span> === <span class="nb">Int</span>        <span class="c1">#=&gt; True</span>

<span class="c1">## - `~~` is the smart match operator</span>
<span class="c1">## Aliases the left hand side to $_ and then evaluates the right hand side.</span>
<span class="c1">## Here are some common comparison semantics:</span>

<span class="c1">## String or numeric equality</span>
<span class="s">'Foo'</span> ~~ <span class="s">'Foo'</span>; <span class="c1"># True if strings are equal.</span>
<span class="mf">12.5</span> ~~ <span class="mf">12.50</span>;  <span class="c1"># True if numbers are equal.</span>

<span class="c1">## Regex - For matching a regular expression against the left side.</span>
<span class="c1">## Returns a `Match` object, which evaluates as True if regexp matches.</span>

<span class="k">my</span> <span class="nv">$obj</span> = <span class="s">'abc'</span> ~~<span class="sr"> /a/</span>;
<span class="nb">say</span> <span class="nv">$obj</span>;       <span class="c1">#=&gt; ｢a｣</span>
<span class="nb">say</span> <span class="nv">$obj</span>.<span class="nb">WHAT</span>;  <span class="c1">#=&gt; (Match)</span>

<span class="c1">## Hashes</span>
<span class="s">'key'</span> ~~ <span class="nv">%hash</span>; <span class="c1"># True if key exists in hash.</span>

<span class="c1">## Type - Checks if left side "is of type" (can check superclasses and</span>
<span class="c1">## roles).</span>
<span class="nb">say</span> <span class="mi">1</span> ~~ <span class="nb">Int</span>;       <span class="c1">#=&gt; True</span>

<span class="c1">## Smart-matching against a boolean always returns that boolean</span>
<span class="c1">## (and will warn).</span>
<span class="nb">say</span> <span class="mi">1</span> ~~ <span class="nb">True</span>;      <span class="c1">#=&gt; True</span>
<span class="nb">say</span> <span class="nb">False</span> ~~ <span class="nb">True</span>;  <span class="c1">#=&gt; True</span>

<span class="c1">## General syntax is `$arg ~~ &amp;bool-returning-function;`. For a complete list</span>
<span class="c1">## of combinations, use this table:</span>
<span class="c1">## http://perlcabal.org/syn/S03.html#Smart_matching</span>

<span class="c1">## Of course, you also use `&lt;`, `&lt;=`, `&gt;`, `&gt;=` for numeric comparison.</span>
<span class="c1">## Their string equivalent are also available: `lt`, `le`, `gt`, `ge`.</span>
<span class="mi">3</span> &gt; <span class="mi">4</span>;       <span class="c1"># False</span>
<span class="mi">3</span> &gt;= <span class="mi">4</span>;      <span class="c1"># False</span>
<span class="mi">3</span> &lt; <span class="mi">4</span>;       <span class="c1"># True</span>
<span class="mi">3</span> &lt;= <span class="mi">4</span>;      <span class="c1"># True</span>
<span class="s">'a'</span> <span class="o">gt</span> <span class="s">'b'</span>;  <span class="c1"># False</span>
<span class="s">'a'</span> <span class="o">ge</span> <span class="s">'b'</span>;  <span class="c1"># False</span>
<span class="s">'a'</span> <span class="o">lt</span> <span class="s">'b'</span>;  <span class="c1"># True</span>
<span class="s">'a'</span> <span class="o">le</span> <span class="s">'b'</span>;  <span class="c1"># True</span>


<span class="c1">## Range constructor</span>
<span class="c1">##------------------</span>
<span class="mi">3</span> .. <span class="mi">7</span>;          <span class="c1"># 3 to 7, both included</span>
<span class="mi">3</span> ..^ <span class="mi">7</span>;         <span class="c1"># 3 to 7, exclude right endpoint.</span>
<span class="mi">3</span> ^.. <span class="mi">7</span>;         <span class="c1"># 3 to 7, exclude left endpoint. Same as `4..7`.</span>
<span class="mi">3</span> ^..^ <span class="mi">7</span>;        <span class="c1"># 3 to 7, exclude both endpoints. Same as `4..6`.</span>

<span class="c1">## This also works as a shortcut for `0..^N`:</span>
^<span class="mi">10</span>;             <span class="c1"># means 0..^10</span>

<span class="c1">## This also allows us to demonstrate that Perl 6 has lazy/infinite arrays,</span>
<span class="c1">## using the Whatever Star:</span>
<span class="k">my</span> <span class="nv">@array</span> = <span class="mi">1</span>..*;  <span class="c1"># 1 to Infinite! Equivalent to `1..Inf`.</span>
<span class="nb">say</span> <span class="nv">@array</span>[^<span class="mi">10</span>];   <span class="c1"># You can pass ranges as subscripts and it'll return</span>
                   <span class="c1"># an array of results. This will print</span>
                   <span class="c1"># "1 2 3 4 5 6 7 8 9 10" (and not run out of memory!)</span>

<span class="c1">## Note: when reading an infinite list, Perl 6 will "reify" the elements</span>
<span class="c1">## it needs, then keep them in memory. They won't be calculated more than once.</span>
<span class="c1">## It also will never calculate more elements that are needed.</span>

<span class="c1">## An array subscript can also be a closure. It'll be called with the length</span>
<span class="c1">## as the argument:</span>
<span class="nb">say</span> <span class="nb">join</span>(<span class="s">' '</span>, <span class="nv">@array</span>[<span class="mi">15</span>..*]); <span class="c1">#=&gt; 15 16 17 18 19</span>
<span class="c1">## which is equivalent to:</span>
<span class="nb">say</span> <span class="nb">join</span>(<span class="s">' '</span>, <span class="nv">@array</span>[-&gt; <span class="nv">$n</span> { <span class="mi">15</span>..<span class="nv">$n</span> }]);

<span class="c1">## Note: if you try to do either of those with an infinite array,</span>
<span class="c1">##       you'll trigger an infinite loop (your program won't finish).</span>

<span class="c1">## You can use that in most places you'd expect, even when assigning to</span>
<span class="c1">## an array:</span>
<span class="k">my</span> <span class="nv">@numbers</span> = ^<span class="mi">20</span>;

<span class="c1">## Here the numbers increase by 6, like an arithmetic sequence; more on the</span>
<span class="c1">## sequence (`...`) operator later.</span>
<span class="k">my</span> <span class="nv">@seq</span> =  <span class="mi">3</span>, <span class="mi">9</span> ... * &gt; <span class="mi">95</span>;  <span class="c1"># 3 9 15 21 27 [...] 81 87 93 99;</span>
<span class="nv">@numbers</span>[<span class="mi">5</span>..*] = <span class="mi">3</span>, <span class="mi">9</span> ... *; <span class="c1"># even though the sequence is infinite,</span>
                             <span class="c1"># only the 15 needed values will be calculated.</span>
<span class="nb">say</span> <span class="nv">@numbers</span>;                <span class="c1">#=&gt; 0 1 2 3 4 3 9 15 21 [...] 81 87</span>
                             <span class="c1"># (only 20 values)</span>

<span class="c1">## and (&amp;&amp;), or (||)</span>
<span class="c1">##------------------</span>
<span class="mi">3</span> &amp;&amp; <span class="mi">4</span>;     <span class="c1"># 4, which is Truthy. Calls `.Bool` on both 3 and 4 and gets `True`</span>
            <span class="c1"># so it returns 4 since both are `True`.</span>
<span class="mi">3</span> &amp;&amp; <span class="mi">0</span>;     <span class="c1"># 0</span>
<span class="mi">0</span> &amp;&amp; <span class="mi">4</span>;     <span class="c1"># 0</span>

<span class="mi">0</span> || <span class="nb">False</span>; <span class="c1"># False. Calls `.Bool` on `0` and `False` which are both `False`</span>
            <span class="c1"># so it retusns `False` since both are `False`.</span>

<span class="c1">## Short-circuit (and tight) versions of the above</span>
<span class="c1">## Return the first argument that evaluates to False, or the last argument.</span>

<span class="k">my</span> ( <span class="nv">$a</span>, <span class="nv">$b</span>, <span class="nv">$c</span> ) = <span class="mi">1</span>, <span class="mi">0</span>, <span class="mi">2</span>;
<span class="nv">$a</span> &amp;&amp; <span class="nv">$b</span> &amp;&amp; <span class="nv">$c</span>; <span class="c1"># Returns 0, the first False value</span>

<span class="c1">## || Returns the first argument that evaluates to True</span>
<span class="nv">$b</span> || <span class="nv">$a</span>; <span class="c1"># 1</span>

<span class="c1">## And because you're going to want them, you also have compound assignment</span>
<span class="c1">## operators:</span>
<span class="nv">$a</span> *= <span class="mi">2</span>;        <span class="c1"># multiply and assignment. Equivalent to $a = $a * 2;</span>
<span class="nv">$b</span> %%= <span class="mi">5</span>;       <span class="c1"># divisible by and assignment. Equivalent to $b = $b %% 2;</span>
<span class="nv">$c</span> <span class="o">div</span>= <span class="mi">3</span>;      <span class="c1"># return divisor and assignment. Equivalent to $c = $c div 3;</span>
<span class="nv">$d</span> <span class="o">mod</span>= <span class="mi">4</span>;      <span class="c1"># return remainder and assignment. Equivalent to $d = $d mod 4;</span>
<span class="nv">@array</span> .= <span class="nb">sort</span>; <span class="c1"># calls the `sort` method and assigns the result back</span>
</pre></div>
<h2>More on subs!</h2>
<div class="highlight"><pre><span></span><span class="c1">## As we said before, Perl 6 has *really* powerful subs. We're going</span>
<span class="c1">## to see a few more key concepts that make them better than in any</span>
<span class="c1">## other language :-).</span>
</pre></div>
<h3>Unpacking!</h3>
<div class="highlight"><pre><span></span><span class="c1">## Unpacking is the ability to "extract" arrays and keys</span>
<span class="c1">## (AKA "destructuring"). It'll work in `my`s and in parameter lists.</span>
<span class="k">my</span> (<span class="nv">$f</span>, <span class="nv">$g</span>) = <span class="mi">1</span>, <span class="mi">2</span>;
<span class="nb">say</span> <span class="nv">$f</span>;                  <span class="c1">#=&gt; 1</span>
<span class="k">my</span> ($, $, <span class="nv">$h</span>) = <span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">3</span>; <span class="c1"># keep the non-interesting values anonymous (`$`)</span>
<span class="nb">say</span> <span class="nv">$h</span>;                  <span class="c1">#=&gt; 3</span>

<span class="k">my</span> (<span class="nv">$head</span>, *<span class="nv">@tail</span>) = <span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">3</span>; <span class="c1"># Yes, it's the same as with "slurpy subs"</span>
<span class="k">my</span> (*<span class="nv">@small</span>) = <span class="mi">1</span>;

<span class="k">sub</span> <span class="n">unpack_array</span>( <span class="nv">@array</span> [<span class="nv">$fst</span>, <span class="nv">$snd</span>] ) {
  <span class="nb">say</span> <span class="s">"My first is $fst, my second is $snd! All in all, I'm @array[]."</span>;
  <span class="c1"># (^ remember the `[]` to interpolate the array)</span>
}
<span class="n">unpack_array</span>(<span class="nv">@tail</span>); <span class="c1">#=&gt; My first is 2, my second is 3! All in all, I'm 2 3.</span>


<span class="c1">## If you're not using the array itself, you can also keep it anonymous,</span>
<span class="c1">## much like a scalar:</span>
<span class="k">sub</span> <span class="n">first-of-array</span>( @ [<span class="nv">$fst</span>] ) { <span class="nv">$fst</span> }
<span class="n">first-of-array</span>(<span class="nv">@small</span>); <span class="c1">#=&gt; 1</span>
<span class="n">first-of-array</span>(<span class="nv">@tail</span>);  <span class="c1"># Error: "Too many positional parameters passed"</span>
                        <span class="c1"># (which means the array is too big).</span>

<span class="c1">## You can also use a slurp...</span>
<span class="k">sub</span> <span class="n">slurp-in-array</span>(@ [<span class="nv">$fst</span>, *<span class="nv">@rest</span>]) { <span class="c1"># You could keep `*@rest` anonymous</span>
    <span class="nb">say</span> <span class="nv">$fst</span> + <span class="nv">@rest</span>.<span class="nb">elems</span>;            <span class="c1"># `.elems` returns a list's length.</span>
                                       <span class="c1"># Here, `@rest` is `(3,)`, since `$fst`</span>
                                       <span class="c1"># holds the `2`.</span>
}
<span class="n">slurp-in-array</span>(<span class="nv">@tail</span>);                 <span class="c1">#=&gt; 3</span>

<span class="c1">## You could even extract on a slurpy (but it's pretty useless ;-).)</span>
<span class="k">sub</span> <span class="n">fst</span>(*@ [<span class="nv">$fst</span>]) { <span class="c1"># or simply: `sub fst($fst) { ... }`</span>
    <span class="nb">say</span> <span class="nv">$fst</span>;
}
<span class="n">fst</span>(<span class="mi">1</span>);    <span class="c1">#=&gt; 1</span>
<span class="n">fst</span>(<span class="mi">1</span>, <span class="mi">2</span>); <span class="c1"># errors with "Too many positional parameters passed"</span>

<span class="c1">## You can also destructure hashes (and classes, which you'll learn about</span>
<span class="c1">## later). The syntax is basically the same as</span>
<span class="c1">## `%hash-name (:key($variable-to-store-value-in))`.</span>
<span class="c1">## The hash can stay anonymous if you only need the values you extracted.</span>
<span class="k">sub</span> <span class="n">key-of</span>( % (:<span class="n">value</span>(<span class="nv">$val</span>), :<span class="n">qua</span>(<span class="nv">$qua</span>)) ) {
    <span class="nb">say</span> <span class="s">"Got val $val, $qua times."</span>;
}

<span class="c1">## Then call it with a hash. You need to keep the curly braces for it to be a</span>
<span class="c1">## hash or use `%()` instead to indicate a hash is being passed.</span>
<span class="n">key-of</span>({<span class="nb">value</span> =&gt; <span class="s">'foo'</span>, <span class="n">qua</span> =&gt; <span class="mi">1</span>});  <span class="c1">#=&gt; Got val foo, 1 times.</span>
<span class="n">key-of</span>(%(<span class="nb">value</span> =&gt; <span class="s">'foo'</span>, <span class="n">qua</span> =&gt; <span class="mi">1</span>)); <span class="c1">#=&gt; Got val foo, 1 times.</span>
<span class="c1">#key-of(%hash); # the same (for an equivalent `%hash`)</span>

<span class="c1">## The last expression of a sub is returned automatically (though you may</span>
<span class="c1">## indicate explicitly by using the `return` keyword, of course):</span>
<span class="k">sub</span> <span class="n">next-index</span>( <span class="nv">$n</span> ) {
    <span class="nv">$n</span> + <span class="mi">1</span>;
}
<span class="k">my</span> <span class="nv">$new-n</span> = <span class="n">next-index</span>(<span class="mi">3</span>); <span class="c1"># $new-n is now 4</span>

<span class="c1">## This is true for everything, except for the looping constructs (due to</span>
<span class="c1">## performance reasons): there's no reason to build a list if we're just going to</span>
<span class="c1">## discard all the results. If you still want to build one, you can use the</span>
<span class="c1">## `do` statement prefix or the `gather` prefix, which we'll see later:</span>

<span class="k">sub</span> <span class="n">list-of</span>( <span class="nv">$n</span> ) {
    <span class="k">do</span> <span class="k">for</span> ^<span class="nv">$n</span> { <span class="c1"># note the range-to prefix operator `^` (`0..^N`)</span>
        <span class="nv">$_</span>       <span class="c1"># current loop iteration known as the "topic" variable</span>
    }
}
<span class="k">my</span> <span class="nv">@list3</span> = <span class="n">list-of</span>(<span class="mi">3</span>); <span class="c1">#=&gt; (0, 1, 2)</span>
</pre></div>
<h3>lambdas (or anonymous subroutines)</h3>
<div class="highlight"><pre><span></span><span class="c1">## You can create a lambda with `-&gt; {}` ("pointy block") ,</span>
<span class="c1">## `{}` ("block") or `sub {}`.</span>

<span class="k">my</span> <span class="nv">&amp;lambda1</span> = -&gt; <span class="nv">$argument</span> {
    <span class="s">"The argument passed to this lambda is $argument"</span>
}

<span class="k">my</span> <span class="nv">&amp;lambda2</span> = {
    <span class="s">"The argument passed to this lambda is $_"</span>
}

<span class="k">my</span> <span class="nv">&amp;lambda3</span> = <span class="k">sub</span> (<span class="nv">$argument</span>) {
    <span class="s">"The argument passed to this lambda is $argument"</span>
}

<span class="c1">## `-&gt; {}` and `{}` are pretty much the same thing, except that the former can</span>
<span class="c1">## take arguments, and that the latter can be mistaken as a hash by the parser.</span>

<span class="c1">## We can, for example, add 3 to each value of an array using the</span>
<span class="c1">## `map` function with a lambda:</span>
<span class="k">my</span> <span class="nv">@arrayplus3</span> = <span class="nb">map</span>({ <span class="nv">$_</span> + <span class="mi">3</span> }, <span class="nv">@array</span>); <span class="c1"># $_ is the implicit argument</span>

<span class="c1">## A sub (`sub {}`) has different semantics than a block (`{}` or `-&gt; {}`):</span>
<span class="c1">## A block doesn't have a "function context" (though it can have arguments),</span>
<span class="c1">## which means that if you return from it, you're going to return from the</span>
<span class="c1">## parent function. Compare:</span>
<span class="k">sub</span> <span class="n">is-in</span>( <span class="nv">@array</span>, <span class="nv">$elem</span> ) {
    <span class="c1"># this will `return` out of the `is-in` sub once the condition evaluated</span>
    <span class="c1">## to True, the loop won't be run anymore.</span>
    <span class="nb">map</span>({ <span class="k">return</span> <span class="nb">True</span> <span class="k">if</span> <span class="nv">$_</span> == <span class="nv">$elem</span> }, <span class="nv">@array</span>);
}
<span class="c1">## with:</span>
<span class="k">sub</span> <span class="n">truthy-array</span>( <span class="nv">@array</span> ) {
    <span class="c1"># this will produce an array of `True` and `False`:</span>
    <span class="c1"># (you can also say `anon sub` for "anonymous subroutine")</span>
    <span class="nb">map</span>(<span class="k">sub</span> (<span class="nv">$i</span>) { <span class="k">if</span> <span class="nv">$i</span> { <span class="k">return</span> <span class="nb">True</span> } <span class="k">else</span> { <span class="k">return</span> <span class="nb">False</span> } }, <span class="nv">@array</span>);
    <span class="c1"># ^ the `return` only returns from the anonymous `sub`</span>
}

<span class="c1">## The `anon` declarator can be used to create an anonymous sub from a</span>
<span class="c1">## regular subroutine. The regular sub knows its name but its symbol is</span>
<span class="c1">## prevented from getting installed in the lexical scope, the method table</span>
<span class="c1">## and everywhere else.</span>

<span class="k">my</span> <span class="nv">$anon-sum</span> = <span class="n">anon</span> <span class="k">sub</span> <span class="n">summation</span>(*<span class="nv">@a</span>) { [+] *<span class="nv">@a</span> }
<span class="nb">say</span> <span class="nv">$anon-sum</span>.<span class="nb">name</span>;     <span class="c1">#=&gt; summation</span>
<span class="nb">say</span> <span class="nv">$anon-sum</span>(<span class="mi">2</span>, <span class="mi">3</span>, <span class="mi">5</span>); <span class="c1">#=&gt; 10</span>
<span class="c1">#say summation;         #=&gt; Error: Undeclared routine: ...</span>

<span class="c1">## You can also use the "whatever star" to create an anonymous subroutine.</span>
<span class="c1">## (it'll stop at the furthest operator in the current expression)</span>
<span class="k">my</span> <span class="nv">@arrayplus3</span> = <span class="nb">map</span>(*+<span class="mi">3</span>, <span class="nv">@array</span>);   <span class="c1"># `*+3` is the same as `{ $_ + 3 }`</span>
<span class="k">my</span> <span class="nv">@arrayplus3</span> = <span class="nb">map</span>(*+*+<span class="mi">3</span>, <span class="nv">@array</span>); <span class="c1"># Same as `-&gt; $a, $b { $a + $b + 3 }`</span>
                                     <span class="c1"># also `sub ($a, $b) { $a + $b + 3 }`</span>
<span class="nb">say</span> (*/<span class="mi">2</span>)(<span class="mi">4</span>);     <span class="c1">#=&gt; 2</span>
                  <span class="c1"># Immediately execute the function Whatever created.</span>
<span class="nb">say</span> ((*+<span class="mi">3</span>)/<span class="mi">5</span>)(<span class="mi">5</span>); <span class="c1">#=&gt; 1.6</span>
                  <span class="c1"># It works even in parens!</span>

<span class="c1">## But if you need to have more than one argument (`$_`) in a block (without</span>
<span class="c1">## wanting to resort to `-&gt; {}`), you can also use the implicit argument</span>
<span class="c1">## syntax, `$^`:</span>
<span class="nb">map</span>({ <span class="nv">$^a</span> + <span class="nv">$^b</span> + <span class="mi">3</span> }, <span class="nv">@array</span>);
<span class="c1"># which is equivalent to the following which uses a `sub`:</span>
<span class="nb">map</span>(<span class="k">sub</span> (<span class="nv">$a</span>, <span class="nv">$b</span>) { <span class="nv">$a</span> + <span class="nv">$b</span> + <span class="mi">3</span> }, <span class="nv">@array</span>);

<span class="c1">## The parameters `$^a`, `$^b`, etc. are known as placeholder parameters or</span>
<span class="c1">## self-declared positional parameters. They're sorted lexicographically so</span>
<span class="c1">## `{ $^b / $^a }` is equivalent `-&gt; $a, $b { $b / $a }`.</span>
</pre></div>
<h3>About types…</h3>
<div class="highlight"><pre><span></span><span class="c1">## Perl 6 is gradually typed. This means you can specify the type of your</span>
<span class="c1">## variables/arguments/return types, or you can omit the type annotations in</span>
<span class="c1">## in which case they'll default to `Any`. Obviously you get access to a few</span>
<span class="c1">## base types, like `Int` and `Str`. The constructs for declaring types are</span>
<span class="c1">## "subset", "class", "role", etc. which you'll see later.</span>

<span class="c1">## For now, let us examine "subset" which is a "sub-type" with additional</span>
<span class="c1">## checks. For example, "a very big integer is an Int that's greater than 500".</span>
<span class="c1">## You can specify the type you're subtyping (by default, `Any`), and add</span>
<span class="c1">## additional checks with the `where` clause:</span>
<span class="k">subset</span> <span class="n">VeryBigInteger</span> <span class="k">of</span> <span class="nb">Int</span> <span class="k">where</span> * &gt; <span class="mi">500</span>;
<span class="c1">## Or the set of the whole numbers:</span>
<span class="k">subset</span> <span class="n">WholeNumber</span> <span class="k">of</span> <span class="nb">Int</span> <span class="k">where</span> * &gt;= <span class="mi">0</span>;
</pre></div>
<h3>Multiple Dispatch</h3>
<div class="highlight"><pre><span></span><span class="c1">## Perl 6 can decide which variant of a `sub` to call based on the type of the</span>
<span class="c1">## arguments, or on arbitrary preconditions, like with a type or `where`:</span>

<span class="c1">## with types:</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="n">sayit</span>( <span class="nb">Int</span> <span class="nv">$n</span> ) { <span class="c1"># note the `multi` keyword here</span>
  <span class="nb">say</span> <span class="s">"Number: $n"</span>;
}
<span class="k">multi</span> <span class="n">sayit</span>( <span class="nb">Str</span> <span class="nv">$s</span> ) {     <span class="c1"># a multi is a `sub` by default</span>
  <span class="nb">say</span> <span class="s">"String: $s"</span>;
}
<span class="n">sayit</span>(<span class="s">"foo"</span>); <span class="c1">#=&gt; "String: foo"</span>
<span class="n">sayit</span>(<span class="mi">25</span>);    <span class="c1">#=&gt; "Number: 25"</span>
<span class="n">sayit</span>(<span class="nb">True</span>);  <span class="c1"># fails at *compile time* with "calling 'sayit' will never</span>
              <span class="c1"># work with arguments of types ..."</span>

<span class="c1">## with arbitrary preconditions (remember subsets?):</span>
<span class="k">multi</span> <span class="n">is-big</span>(<span class="nb">Int</span> <span class="nv">$n</span> <span class="k">where</span> * &gt; <span class="mi">50</span>) { <span class="s">"Yes!"</span> }    <span class="c1"># using a closure</span>
<span class="k">multi</span> <span class="n">is-big</span>(<span class="nb">Int</span> <span class="nv">$n</span> <span class="k">where</span> {<span class="nv">$_</span> &gt; <span class="mi">50</span>}) { <span class="s">"Yes!"</span> } <span class="c1"># similar to above</span>
<span class="k">multi</span> <span class="n">is-big</span>(<span class="nb">Int</span> $ <span class="k">where</span> <span class="mi">10</span><span class="o">..</span><span class="mi">50</span>)  { <span class="s">"Quite."</span> }  <span class="c1"># Using smart-matching</span>
                                                <span class="c1"># (could use a regexp, etc)</span>
<span class="k">multi</span> <span class="n">is-big</span>(<span class="nb">Int</span> $) { <span class="s">"No"</span> }

<span class="k">subset</span> <span class="n">Even</span> <span class="k">of</span> <span class="nb">Int</span> <span class="k">where</span> * %% <span class="mi">2</span>;
<span class="k">multi</span> <span class="n">odd-or-even</span>(<span class="n">Even</span>) { <span class="s">"Even"</span> } <span class="c1"># The main case using the type.</span>
                                   <span class="c1"># We don't name the argument.</span>
<span class="k">multi</span> <span class="n">odd-or-even</span>($) { <span class="s">"Odd"</span> }     <span class="c1"># "everthing else" hence the $ variable</span>

<span class="c1">## You can even dispatch based on the presence of positional and</span>
<span class="c1">## named arguments:</span>
<span class="k">multi</span> <span class="n">with-or-without-you</span>(<span class="nv">$with</span>) {
     <span class="nb">say</span> <span class="s">"I wish I could but I can't"</span>;
}
<span class="k">multi</span> <span class="n">with-or-without-you</span>(:<span class="nv">$with</span>) {
     <span class="nb">say</span> <span class="s">"I can live! Actually, I can't."</span>;
}
<span class="k">multi</span> <span class="n">with-or-without-you</span> {
     <span class="nb">say</span> <span class="s">"Definitely can't live."</span>;
}

<span class="c1">## This is very, very useful for many purposes, like `MAIN` subs (covered</span>
<span class="c1">## later), and even the language itself uses it in several places.</span>
<span class="c1">##</span>
<span class="c1">## - `is`, for example, is actually a `multi sub` named `trait_mod:&lt;is&gt;`,</span>
<span class="c1">## and it works off that.</span>
<span class="c1">## - `is rw`, is simply a dispatch to a function with this signature:</span>
<span class="c1">## sub trait_mod:&lt;is&gt;(Routine $r, :$rw!) {}</span>
<span class="c1">##</span>
<span class="c1">## (commented out because running this would be a terrible idea!)</span>
</pre></div>
<h2>Scoping</h2>
<div class="highlight"><pre><span></span><span class="c1">## In Perl 6, unlike many scripting languages, (such as Python, Ruby, PHP),</span>
<span class="c1">## you must declare your variables before using them. The `my` declarator</span>
<span class="c1">## you have learned uses "lexical scoping". There are a few other declarators,</span>
<span class="c1">## (`our`, `state`, ..., ) which we'll see later. This is called</span>
<span class="c1">## "lexical scoping", where in inner blocks,  you can access variables from</span>
<span class="c1">## outer blocks.</span>
<span class="k">my</span> <span class="nv">$file_scoped</span> = <span class="s">'Foo'</span>;
<span class="k">sub</span> <span class="n">outer</span> {
    <span class="k">my</span> <span class="nv">$outer_scoped</span> = <span class="s">'Bar'</span>;
    <span class="k">sub</span> <span class="n">inner</span> {
        <span class="nb">say</span> <span class="s">"$file_scoped $outer_scoped"</span>;
    }
    <span class="nv">&amp;inner</span>; <span class="c1"># return the function</span>
}
<span class="n">outer</span>()();  <span class="c1">#=&gt; 'Foo Bar'</span>

<span class="c1">## As you can see, `$file_scoped` and `$outer_scoped` were captured.</span>
<span class="c1">## But if we were to try and use `$outer_scoped` outside the `outer` sub,</span>
<span class="c1">## the variable would be undefined (and you'd get a compile time error).</span>
</pre></div>
<h2>Twigils</h2>
<div class="highlight"><pre><span></span><span class="c1">## There are many special `twigils` (composed sigils) in Perl 6. Twigils</span>
<span class="c1">## define the variables' scope.</span>
<span class="c1">## The * and ? twigils work on standard variables:</span>
<span class="c1">## * Dynamic variable</span>
<span class="c1">## ? Compile-time variable</span>
<span class="c1">## The ! and the . twigils are used with Perl 6's objects:</span>
<span class="c1">## ! Attribute (instance attribute)</span>
<span class="c1">## . Method (not really a variable)</span>

<span class="c1">## `*` twigil: Dynamic Scope</span>
<span class="c1">## These variables use the `*` twigil to mark dynamically-scoped variables.</span>
<span class="c1">## Dynamically-scoped variables are looked up through the caller, not through</span>
<span class="c1">## the outer scope.</span>

<span class="k">my</span> <span class="vg">$*dyn_scoped_1</span> = <span class="mi">1</span>;
<span class="k">my</span> <span class="vg">$*dyn_scoped_2</span> = <span class="mi">10</span>;

<span class="k">sub</span> <span class="n">say_dyn</span> {
    <span class="nb">say</span> <span class="s">"$*dyn_scoped_1 $*dyn_scoped_2"</span>;
}

<span class="k">sub</span> <span class="n">call_say_dyn</span> {
  <span class="k">my</span> <span class="vg">$*dyn_scoped_1</span> = <span class="mi">25</span>; <span class="c1"># Defines $*dyn_scoped_1 only for this sub.</span>
  <span class="vg">$*dyn_scoped_2</span> = <span class="mi">100</span>;   <span class="c1"># Will change the value of the file scoped variable.</span>
  <span class="n">say_dyn</span>();              <span class="c1">#=&gt; 25 100, $*dyn_scoped 1 and 2 will be looked</span>
                          <span class="c1"># for in the call.</span>
                          <span class="c1"># It uses the value of $*dyn_scoped_1 from inside</span>
                          <span class="c1"># this sub's lexical scope even though the blocks</span>
                          <span class="c1"># aren't nested (they're call-nested).</span>
}
<span class="n">say_dyn</span>();      <span class="c1">#=&gt; 1 10</span>
<span class="n">call_say_dyn</span>(); <span class="c1">#=&gt; 25 100</span>
                <span class="c1"># Uses $*dyn_scoped_1 as defined in call_say_dyn even though</span>
                <span class="c1"># we are calling it from outside.</span>
<span class="n">say_dyn</span>();      <span class="c1">#=&gt; 1 100 We changed the value of $*dyn_scoped_2 in</span>
                <span class="c1"># call_say_dyn so now its value has changed.</span>
</pre></div>
<h2>Object Model</h2>
<div class="highlight"><pre><span></span><span class="c1">## To call a method on an object, add a dot followed by the method name:</span>
<span class="c1">## `$object.method`</span>

<span class="c1">## Classes are declared with the `class` keyword. Attributes are declared</span>
<span class="c1">## with the `has` keyword, and methods declared with the `method` keyword.</span>

<span class="c1">## Every attribute that is private uses the ! twigil. For example: `$!attr`.</span>
<span class="c1">## Immutable public attributes use the `.` twigil which creates a read-only</span>
<span class="c1">## method named after the attribute. In fact, declaring an attribute with `.`</span>
<span class="c1">## is equivalent to declaring the same attribute with `!` and then creating</span>
<span class="c1">## a read-only method with the attribute's name. However, this is done for us</span>
<span class="c1">## by Perl 6 automatically. The easiest way to remember the `$.` twigil is</span>
<span class="c1">## by comparing it to how methods are called.</span>

<span class="c1">## Perl 6's object model ("SixModel") is very flexible, and allows you to</span>
<span class="c1">## dynamically add methods, change semantics, etc... Unfortunately, these will</span>
<span class="c1">## not all be covered here, and you should refer to:</span>
<span class="c1">## https://docs.perl6.org/language/objects.html.</span>

<span class="k">class</span> <span class="n">Human</span> {
    <span class="k">has</span> <span class="nb">Str</span> <span class="nv">$.name</span>;           <span class="c1"># `$.name` is immutable but with an accessor method.</span>
    <span class="k">has</span> <span class="nb">Str</span> <span class="nv">$.bcountry</span>;       <span class="c1"># Use `$!bplace` to modify it inside the class.</span>
    <span class="k">has</span> <span class="nb">Str</span> <span class="nv">$.ccountry</span> <span class="k">is</span> <span class="k">rw</span>; <span class="c1"># This attribute can be modified from outside.</span>
    <span class="k">has</span> <span class="nb">Int</span> <span class="nv">$!age</span> = <span class="mi">0</span>;        <span class="c1"># A private attribute with default value.</span>

    <span class="k">method</span> <span class="n">birthday</span> {
        <span class="nv">$!age</span> += <span class="mi">1</span>; <span class="c1"># Add a year to human's age</span>
    }

    <span class="k">method</span> <span class="n">get-age</span> {
        <span class="k">return</span> <span class="nv">$!age</span>;
    }

    <span class="c1"># This method is private to the class. Note the `!` before the</span>
    <span class="c1"># method's name.</span>
    <span class="k">method</span> !<span class="n">do-decoration</span> {
        <span class="k">return</span> <span class="s">"$!name was born in $!bcountry and now lives in  $!ccountry."</span>
    }

    <span class="c1"># This method is public, just like `birthday` and `get-age`.</span>
    <span class="k">method</span> <span class="n">get-info</span> {
        <span class="k">self</span>.<span class="n">do-decoration</span>; <span class="c1"># Invoking a method on `self` inside the class.</span>
                            <span class="c1"># Use `self!priv-method` for private method.</span>
                            <span class="c1"># Use `self.publ-method` for public method.</span>
    }
};

<span class="c1">## Create a new instance of Human class with $.attrib set to 5.</span>
<span class="c1">## Note: you can't set private-attribute from here (more later on).</span>
<span class="k">my</span> <span class="nv">$person1</span> = <span class="n">Human</span>.<span class="nb">new</span>(
    <span class="nb">name</span> =&gt; <span class="s">"Jord"</span>,
    <span class="n">bcountry</span> = <span class="s">"Iceland"</span>,
    <span class="n">ccountry</span> =&gt; <span class="s">"Iceland"</span>
);

<span class="nb">say</span> <span class="nv">$person1</span>.<span class="nb">name</span>;     <span class="c1">#=&gt; Jord</span>
<span class="nb">say</span> <span class="nv">$person1</span>.<span class="n">bcountry</span>; <span class="c1">#=&gt; Togo</span>
<span class="nb">say</span> <span class="nv">$person1</span>.<span class="n">ccountry</span>; <span class="c1">#=&gt; Togo</span>


<span class="c1"># $person1.bcountry = "Mali"; # This fails, because the `has $.bcountry`</span>
                              <span class="c1"># is immutable. Jord can't change his birthplace.</span>
<span class="nv">$person1</span>.<span class="n">ccountry</span> = <span class="s">"France"</span>; <span class="c1"># This works because the `$.ccountry` is mutable</span>
                              <span class="c1"># (`is rw`). Now Jord's current country is France.</span>

<span class="c1"># Calling methods on the instance objects.</span>
<span class="nv">$person1</span>.<span class="n">birthday</span>;      <span class="c1">#=&gt; 1</span>
<span class="nv">$person1</span>.<span class="n">get-info</span>;      <span class="c1">#=&gt; Jord was born in Togo and now lives in France.</span>
<span class="nv">$person1</span>.<span class="n">do-decoration</span>; <span class="c1"># This fails since the method `do-decoration` is</span>
                        <span class="c1"># private.</span>
</pre></div>
<h3>Object Inheritance</h3>
<div class="highlight"><pre><span></span><span class="c1">## Perl 6 also has inheritance (along with multiple inheritance). While</span>
<span class="c1">## methods are inherited, submethods are not. Submethods are useful for</span>
<span class="c1">## object construction and destruction tasks, such as BUILD, or methods that</span>
<span class="c1">## must be overridden by subtypes. We will learn about BUILD later on.</span>

<span class="k">class</span> <span class="n">Parent</span> {
    <span class="k">has</span> <span class="nv">$.age</span>;
    <span class="k">has</span> <span class="nv">$.name</span>;

    <span class="c1"># This submethod won't be inherited by the Child class.</span>
    <span class="k">submethod</span> <span class="n">favorite-color</span> {
        <span class="nb">say</span> <span class="s">"My favorite color is Blue"</span>;
    }

    <span class="c1"># This method is inherited</span>
    <span class="k">method</span> <span class="n">talk</span> { <span class="nb">say</span> <span class="s">"Hi, my name is $!name"</span> }
}

<span class="c1"># Inheritance uses the `is` keyword</span>
<span class="k">class</span> <span class="n">Child</span> <span class="k">is</span> <span class="n">Parent</span> {
    <span class="k">method</span> <span class="n">talk</span> { <span class="nb">say</span> <span class="s">"Goo goo ga ga"</span> }
    <span class="c1"># This shadows Parent's `talk` method.</span>
    <span class="c1"># This child hasn't learned to speak yet!</span>
}

<span class="k">my</span> <span class="n">Parent</span> <span class="nv">$Richard</span> .= <span class="nb">new</span>(<span class="n">age</span> =&gt; <span class="mi">40</span>, <span class="nb">name</span> =&gt; <span class="s">'Richard'</span>);
<span class="nv">$Richard</span>.<span class="n">favorite-color</span>;  <span class="c1">#=&gt; "My favorite color is Blue"</span>
<span class="nv">$Richard</span>.<span class="n">talk</span>;            <span class="c1">#=&gt; "Hi, my name is Richard"</span>
<span class="c1">## $Richard is able to access the submethod and he knows how to say his name.</span>

<span class="k">my</span> <span class="n">Child</span> <span class="nv">$Madison</span> .= <span class="nb">new</span>(<span class="n">age</span> =&gt; <span class="mi">1</span>, <span class="nb">name</span> =&gt; <span class="s">'Madison'</span>);
<span class="nv">$Madison</span>.<span class="n">talk</span>;            <span class="c1">#=&gt; "Goo goo ga ga", due to the overridden method.</span>
<span class="c1"># $Madison.favorite-color # does not work since it is not inherited.</span>

<span class="c1">## When you use `my T $var`, `$var` starts off with `T` itself in it,</span>
<span class="c1">## so you can call `new` on it.</span>
<span class="c1">## (`.=` is just the dot-call and the assignment operator:</span>
<span class="c1">## `$a .= b` is the same as `$a = $a.b`)</span>
<span class="c1">## Also note that `BUILD` (the method called inside `new`)</span>
<span class="c1">## will set parent's properties too, so you can pass `val =&gt; 5`.</span>
</pre></div>
<h3>Roles, or Mixins</h3>
<div class="highlight"><pre><span></span><span class="c1">## Roles are supported too (which are called Mixins in other languages)</span>
<span class="k">role</span> <span class="n">PrintableVal</span> {
    <span class="k">has</span> <span class="nv">$!counter</span> = <span class="mi">0</span>;
    <span class="k">method</span> <span class="nb">print</span> {
        <span class="nb">say</span> <span class="nv">$.val</span>;
    }
}

<span class="c1">## you "apply" a role (or mixin) with `does` keyword:</span>
<span class="k">class</span> <span class="n">Item</span> <span class="nb">does</span> <span class="n">PrintableVal</span> {
    <span class="k">has</span> <span class="nv">$.val</span>;

    <span class="c1">## When `does`-ed, a `role` literally "mixes in" the class:</span>
    <span class="c1">## the methods and attributes are put together, which means a class</span>
    <span class="c1">## can access the private attributes/methods of its roles (but</span>
    <span class="c1">## not the inverse!):</span>
    <span class="k">method</span> <span class="n">access</span> {
        <span class="nb">say</span> <span class="nv">$!counter</span>++;
    }

  <span class="c1">## However, this:</span>
  <span class="c1">## method print {}</span>
  <span class="c1">## is ONLY valid when `print` isn't a `multi` with the same dispatch.</span>
  <span class="c1">## (this means a parent class can shadow a child class's `multi print() {}`,</span>
  <span class="c1">##  but it's an error if a role does)</span>

  <span class="c1">## NOTE: You can use a role as a class (with `is ROLE`). In this case,</span>
  <span class="c1">##       methods will be shadowed, since the compiler will consider `ROLE`</span>
  <span class="c1">##       to be a class.</span>
}
</pre></div>
<h2>Exceptions</h2>
<div class="highlight"><pre><span></span><span class="c1">## Exceptions are built on top of classes, in the package `X` (like `X::IO`).</span>
<span class="c1">## In Perl6 exceptions are automatically 'thrown':</span>
<span class="nb">open</span> <span class="s">'foo'</span>;   <span class="c1">#=&gt; Failed to open file foo: no such file or directory</span>
<span class="c1">## It will also print out what line the error was thrown at</span>
<span class="c1">## and other error info.</span>

<span class="c1">## You can throw an exception using `die`:</span>
<span class="k">die</span> <span class="s">'Error!'</span>; <span class="c1">#=&gt; Error!</span>

<span class="c1">## Or more explicitly:</span>
<span class="o">X</span>::<span class="n">AdHoc</span>.<span class="nb">new</span>(<span class="n">payload</span> =&gt; <span class="s">'Error!'</span>).<span class="n">throw</span>; <span class="c1">#=&gt; Error!</span>

<span class="c1">## In Perl 6, `orelse` is similar to the `or` operator, except it only matches</span>
<span class="c1">## undefined variables instead of anything evaluating as `False`.</span>
<span class="c1">## Undefined values include: `Nil`, `Mu` and `Failure` as well as `Int`, `Str`</span>
<span class="c1">## and other types that have not been initialized to any value yet.</span>
<span class="c1">## You can check if something is defined or not using the defined method:</span>
<span class="k">my</span> <span class="nv">$uninitialized</span>;
<span class="nb">say</span> <span class="nv">$uninitiazilzed</span>.<span class="nb">defined</span>; <span class="c1">#=&gt; False</span>

<span class="c1">## When using `orelse` it will disarm the exception and alias $_ to that</span>
<span class="c1">## failure. This will prevent it to being automatically handled and printing</span>
<span class="c1">## lots of scary error messages to the screen. We can use the `exception`</span>
<span class="c1">## method on the `$_` variable to access the exception</span>
<span class="nb">open</span> <span class="s">'foo'</span> <span class="o">orelse</span> <span class="nb">say</span> <span class="s">"Something happened {.exception}"</span>;

<span class="c1">## This also works:</span>
<span class="nb">open</span> <span class="s">'foo'</span> <span class="o">orelse</span> <span class="nb">say</span> <span class="s">"Something happened $_"</span>; <span class="c1">#=&gt; Something happened</span>
              <span class="c1">#=&gt;  Failed to open file foo: no such file or directory</span>
<span class="c1">## Both of those above work but in case we get an object from the left side</span>
<span class="c1">## that is not a failure we will probably get a warning. We see below how we</span>
<span class="c1">## can use try` and `CATCH` to be more specific with the exceptions we catch.</span>
</pre></div>
<h3>Using <code>try</code> and <code>CATCH</code></h3>
<div class="highlight"><pre><span></span><span class="c1">## By using `try` and `CATCH` you can contain and handle exceptions without</span>
<span class="c1">## disrupting the rest of the program. The `try` block will set the last</span>
<span class="c1">## exception to the special variable `$!` (known as the error variable).</span>
<span class="c1">## Note: This has no relation to $!variables seen inside class definitions.</span>

<span class="k">try</span> <span class="nb">open</span> <span class="s">'foo'</span>;
<span class="nb">say</span> <span class="s">"Well, I tried! $!"</span> <span class="k">if</span> <span class="nb">defined</span> <span class="vg">$!</span>;
<span class="c1">#=&gt; Well, I tried! Failed to open file foo: no such file or directory</span>

<span class="c1">## Now, what if we want more control over handling the exception?</span>
<span class="c1">## Unlike many other languages, in Perl 6, you put the `CATCH` block *within*</span>
<span class="c1">## the block to `try`. Similar to how the `$_` variable was set when we</span>
<span class="c1">## 'disarmed' the exception with `orelse`, we also use `$_` in the CATCH block.</span>
<span class="c1">## Note: The `$!` variable is only set *after* the `try` block has caught an</span>
<span class="c1">## exception. By default, a `try` block has a `CATCH` block of its own that</span>
<span class="c1">## catches any exception (`CATCH { default {} }`).</span>

<span class="k">try</span> {
    <span class="k">my</span> <span class="nv">$a</span> = (<span class="mi">0</span> %% <span class="mi">0</span>);
    <span class="k">CATCH</span> {
        <span class="nb">say</span> <span class="s">"Something happened: $_"</span>
    }
}
<span class="c1">#=&gt; Something happened: Attempt to divide by zero using infix:&lt;%%&gt;</span>

<span class="c1">## You can redefine it using `when`s (and `default`) to handle the exceptions</span>
<span class="c1">## you want to catch explicitly:</span>

<span class="k">try</span> {
  <span class="nb">open</span> <span class="s">'foo'</span>;
    <span class="k">CATCH</span> {
        <span class="c1"># In the `CATCH` block, the exception is set to the $_ variable.</span>
        <span class="k">when</span> <span class="o">X</span>::<span class="n">AdHoc</span> {
            <span class="nb">say</span> <span class="s">"Error: $_"</span>
        }
        <span class="k">when</span> <span class="o">X</span>::<span class="n">Numeric::DivideByZero</span> {
            <span class="nb">say</span> <span class="s">"Error: $_"</span>;
        }
    <span class="c1">## Any other exceptions will be re-raised, since we don't have a `default`.</span>
    <span class="c1">## Basically, if a `when` matches (or there's a `default`), the</span>
    <span class="c1">## exception is marked as "handled" so as to prevent its re-throw</span>
    <span class="c1">## from the `CATCH` block. You still can re-throw the exception (see below)</span>
    <span class="c1">## by hand.</span>
  }
}
<span class="c1">#=&gt;Error: Failed to open file /dir/foo: no such file or directory</span>

<span class="c1">## There are also some subtleties to exceptions. Some Perl 6 subs return a</span>
<span class="c1">## `Failure`, which is a wrapper around an `Exception` object which is</span>
<span class="c1">## "unthrown". They're not thrown until you try to use the variables containing</span>
<span class="c1">## them unless you call `.Bool`/`.defined` on them - then they're handled.</span>
<span class="c1">## (the `.handled` method is `rw`, so you can mark it as `False` back yourself)</span>
<span class="c1">## You can throw a `Failure` using `fail`. Note that if the pragma `use fatal`</span>
<span class="c1">## is on, `fail` will throw an exception (like `die`).</span>

<span class="k">fail</span> <span class="s">"foo"</span>; <span class="c1"># We're not trying to access the value, so no problem.</span>
<span class="k">try</span> {
    <span class="k">fail</span> <span class="s">"foo"</span>;
    <span class="k">CATCH</span> {
        <span class="k">default</span> {
            <span class="nb">say</span> <span class="s">"It threw because we tried to get the fail's value!"</span>
        }
  }
}

<span class="c1">## There is also another kind of exception: Control exceptions.</span>
<span class="c1">## Those are "good" exceptions, which happen when you change your program's</span>
<span class="c1">## flow, using operators like `return`, `next` or `last`.</span>
<span class="c1">## You can "catch" those with `CONTROL` (not 100% working in Rakudo yet).</span>
</pre></div>
<h2>Packages</h2>
<div class="highlight"><pre><span></span><span class="c1">## Packages are a way to reuse code. Packages are like "namespaces", and any</span>
<span class="c1">## element of the six model (`module`, `role`, `class`, `grammar`, `subset` and</span>
<span class="c1">## `enum`) are actually packages. (Packages are the lowest common denominator)</span>
<span class="c1">## Packages are important - especially as Perl is well-known for CPAN,</span>
<span class="c1">## the Comprehensive Perl Archive Network.</span>

<span class="c1">## You can use a module (bring its declarations into scope) with</span>
<span class="c1">## the `use` keyword:</span>
<span class="k">use</span> <span class="n">JSON::Tiny</span>; <span class="c1"># if you installed Rakudo* or Panda, you'll have this module</span>
<span class="nb">say</span> <span class="n">from-json</span>(<span class="s">'[1]'</span>).<span class="nb">perl</span>; <span class="c1">#=&gt; [1]</span>

<span class="c1">## You should not declare packages using the `package` keyword (unlike Perl 5).</span>
<span class="c1">## Instead, use `class Package::Name::Here;` to declare a class, or if you only</span>
<span class="c1">## want to export variables/subs, you can use `module` instead.</span>

<span class="k">module</span> <span class="n">Hello::World</span> { <span class="c1"># bracketed form</span>
    <span class="c1"># If `Hello` doesn't exist yet, it'll just be a "stub",</span>
    <span class="c1"># that can be redeclared as something else later.</span>

    <span class="c1"># ... declarations here ...</span>
}

<span class="n">unit</span> <span class="k">module</span> <span class="n">Parse::Text</span>; <span class="c1"># file-scoped form which extends until</span>
                         <span class="c1"># the end of the file</span>

<span class="k">grammar</span> <span class="n">Parse::Text::Grammar</span> {
    <span class="c1"># A grammar is a package, which you could `use`.</span>
    <span class="c1"># You will learn more about grammars in the regex section</span>
}

<span class="c1">## As said before, any part of the six model is also a package.</span>
<span class="c1">## Since `JSON::Tiny` uses its own `JSON::Tiny::Actions` class, you can use it:</span>
<span class="k">my</span> <span class="nv">$actions</span> = <span class="n">JSON::Tiny::Actions</span>.<span class="nb">new</span>;

<span class="c1">## We'll see how to export variables and subs in the next part.</span>
</pre></div>
<h2>Declarators</h2>
<div class="highlight"><pre><span></span><span class="c1">## In Perl 6, you get different behaviors based on how you declare a variable.</span>
<span class="c1">## You've already seen `my` and `has`, we'll now explore the others.</span>

<span class="c1">## `our` - these declarations happen at `INIT` time -- (see "Phasers" below).</span>
<span class="c1">## It's like `my`, but it also creates a package variable. All packagish</span>
<span class="c1">## things such as `class`, `role`, etc. are `our` by default.</span>

<span class="k">module</span> <span class="n">Var::Increment</span> {
    <span class="k">our</span> <span class="nv">$our-var</span> = <span class="mi">1</span>; <span class="c1"># Note: `our`-declared variables cannot be typed.</span>
    <span class="k">my</span> <span class="nv">$my-var</span> = <span class="mi">22</span>;

    <span class="k">our</span> <span class="k">sub</span> <span class="n">Inc</span> {
        <span class="k">our</span> <span class="k">sub</span> <span class="n">available</span> { <span class="c1"># If you try to make inner `sub`s `our`...</span>
                            <span class="c1"># ... Better know what you're doing (Don't !).</span>
            <span class="nb">say</span> <span class="s">"Don't do that. Seriously. You'll get burned."</span>;
        }

        <span class="k">my</span> <span class="k">sub</span> <span class="n">unavailable</span> { <span class="c1"># `sub`s are `my`-declared by default</span>
            <span class="nb">say</span> <span class="s">"Can't access me from outside, I'm 'my'!"</span>;
        }
        <span class="nb">say</span> ++<span class="nv">$our-var</span>; <span class="c1"># Increment the package variable and output its value</span>
  }

}

<span class="nb">say</span> <span class="nv">$Var::Increment::our-var</span>; <span class="c1">#=&gt; 1, this works!</span>
<span class="nb">say</span> <span class="nv">$Var::Increment::my-var</span>;  <span class="c1">#=&gt; (Any), this will not work!</span>

<span class="n">Var::Increment::Inc</span>;          <span class="c1">#=&gt; 2</span>
<span class="n">Var::Increment::Inc</span>;          <span class="c1">#=&gt; 3 , notice how the value of $our-var was</span>
                              <span class="c1"># retained.</span>
<span class="n">Var::Increment::unavailable</span>;  <span class="c1">#=&gt; Could not find symbol '&amp;unavailable'</span>

<span class="c1">## `constant` - these declarations happen at `BEGIN` time. You can use</span>
<span class="c1">## the `constant` keyword to declare a compile-time variable/symbol:</span>
<span class="k">constant</span> <span class="n">Pi</span> = <span class="mf">3.14</span>;
<span class="k">constant</span> <span class="nv">$var</span> = <span class="mi">1</span>;

<span class="c1">## And if you're wondering, yes, it can also contain infinite lists.</span>
<span class="k">constant</span> <span class="n">why-not</span> = <span class="mi">5</span>, <span class="mi">15</span> ... *;
<span class="nb">say</span> <span class="n">why-not</span>[^<span class="mi">5</span>]; <span class="c1">#=&gt; 5 15 25 35 45</span>

<span class="c1">## `state` - these declarations happen at run time, but only once. State</span>
<span class="c1">## variables are only initialized one time. In other languages such as C</span>
<span class="c1">## they exist as `static` variables.</span>
<span class="k">sub</span> <span class="n">fixed-rand</span> {
    <span class="k">state</span> <span class="nv">$val</span> = <span class="nb">rand</span>;
    <span class="nb">say</span> <span class="nv">$val</span>;
}
<span class="n">fixed-rand</span> <span class="k">for</span> ^<span class="mi">10</span>; <span class="c1"># will print the same number 10 times</span>

<span class="c1">## Note, however, that they exist separately in different enclosing contexts.</span>
<span class="c1">## If you declare a function with a `state` within a loop, it'll re-create the</span>
<span class="c1">## variable for each iteration of the loop. See:</span>
<span class="k">for</span> ^<span class="mi">5</span> -&gt; <span class="nv">$a</span> {
    <span class="k">sub</span> <span class="n">foo</span> {
        <span class="k">state</span> <span class="nv">$val</span> = <span class="nb">rand</span>; <span class="c1"># This will be a different value for</span>
                           <span class="c1"># every value of `$a`</span>
    }
    <span class="k">for</span> ^<span class="mi">5</span> -&gt; <span class="nv">$b</span> {
        <span class="nb">say</span> <span class="n">foo</span>;           <span class="c1"># This will print the same value 5 times,</span>
                           <span class="c1"># but only 5. Next iteration will re-run `rand`.</span>
    }
}
</pre></div>
<h2>Phasers</h2>
<div class="highlight"><pre><span></span><span class="c1">## Phasers in Perl 6 are blocks that happen at determined points of time in</span>
<span class="c1">## your program. They are called phasers because they mark a change in the</span>
<span class="c1">## phase of a program.  For example, when the program is compiled, a for loop</span>
<span class="c1">## runs, you leave a block, or an exception gets thrown (The `CATCH` block is</span>
<span class="c1">## actually a phaser!). Some of them can be used for their return values,</span>
<span class="c1">## some of them can't (those that can have a "[*]" in the beginning of their</span>
<span class="c1">## explanation text). Let's have a look!</span>

<span class="c1">## Compile-time phasers</span>
<span class="k">BEGIN</span> { <span class="nb">say</span> <span class="s">"[*] Runs at compile time, as soon as possible, only once"</span> }
<span class="k">CHECK</span> { <span class="nb">say</span> <span class="s">"[*] Runs at compile time, as late as possible, only once"</span> }

<span class="c1">## Run-time phasers</span>
<span class="k">INIT</span> { <span class="nb">say</span> <span class="s">"[*] Runs at run time, as soon as possible, only once"</span> }
<span class="k">END</span>  { <span class="nb">say</span> <span class="s">"Runs at run time, as late as possible, only once"</span> }

<span class="c1">## Block phasers</span>
<span class="k">ENTER</span> { <span class="nb">say</span> <span class="s">"[*] Runs everytime you enter a block, repeats on loop blocks"</span> }
<span class="k">LEAVE</span> {
    <span class="nb">say</span> <span class="s">"Runs everytime you leave a block, even when an exception</span>
<span class="s">    happened. Repeats on loop blocks."</span>
}

<span class="k">PRE</span> {
    <span class="nb">say</span> <span class="s">"Asserts a precondition at every block entry,</span>
<span class="s">        before ENTER (especially useful for loops)"</span>;
    <span class="nb">say</span> <span class="s">"If this block doesn't return a truthy value,</span>
<span class="s">        an exception of type X::Phaser::PrePost is thrown."</span>;
}

<span class="c1">## Example:</span>
<span class="k">for</span> <span class="mi">0</span><span class="o">..</span><span class="mi">2</span> {
    <span class="k">PRE</span> { <span class="nv">$_</span> &gt; <span class="mi">1</span> } <span class="c1"># This is going to blow up with "Precondition failed"</span>
}

<span class="k">POST</span> {
    <span class="nb">say</span> <span class="s">"Asserts a postcondition at every block exit,</span>
<span class="s">        after LEAVE (especially useful for loops)"</span>;
    <span class="nb">say</span> <span class="s">"If this block doesn't return a truthy value,</span>
<span class="s">        an exception of type X::Phaser::PrePost is thrown, like PRE."</span>;
}

<span class="k">for</span> <span class="mi">0</span><span class="o">..</span><span class="mi">2</span> {
    <span class="k">POST</span> { <span class="nv">$_</span> &lt; <span class="mi">2</span> } <span class="c1"># This is going to blow up with "Postcondition failed"</span>
}

<span class="c1">## Block/exceptions phasers</span>
<span class="k">sub</span> {
    <span class="k">KEEP</span> { <span class="nb">say</span> <span class="s">"Runs when you exit a block successfully</span>
<span class="s">                (without throwing an exception)"</span> }
    <span class="k">UNDO</span> { <span class="nb">say</span> <span class="s">"Runs when you exit a block unsuccessfully</span>
<span class="s">                (by throwing an exception)"</span> }
}

<span class="c1">## Loop phasers</span>
<span class="k">for</span> ^<span class="mi">5</span> {
  <span class="k">FIRST</span> { <span class="nb">say</span> <span class="s">"[*] The first time the loop is run, before ENTER"</span> }
  <span class="k">NEXT</span>  { <span class="nb">say</span> <span class="s">"At loop continuation time, before LEAVE"</span> }
  <span class="k">LAST</span>  { <span class="nb">say</span> <span class="s">"At loop termination time, after LEAVE"</span> }
}

<span class="c1">## Role/class phasers</span>
<span class="n">COMPOSE</span> { <span class="s">"When a role is composed into a class. /!\ NOT YET IMPLEMENTED"</span> }

<span class="c1">## They allow for cute tricks or clever code...:</span>
<span class="nb">say</span> <span class="s">"This code took "</span> ~ (<span class="nb">time</span> - <span class="k">CHECK</span> <span class="nb">time</span>) ~ <span class="s">"s to compile"</span>;

<span class="c1">## ... or clever organization:</span>
<span class="k">sub</span> <span class="n">do-db-stuff</span> {
    <span class="nv">$db</span>.<span class="n">start-transaction</span>; <span class="c1"># start a new transaction</span>
    <span class="k">KEEP</span> <span class="nv">$db</span>.<span class="n">commit</span>;       <span class="c1"># commit the transaction if all went well</span>
    <span class="k">UNDO</span> <span class="nv">$db</span>.<span class="n">rollback</span>;     <span class="c1"># or rollback if all hell broke loose</span>
}
</pre></div>
<h2>Statement prefixes</h2>
<div class="highlight"><pre><span></span><span class="c1">## Those act a bit like phasers: they affect the behavior of the following</span>
<span class="c1">## code. Though, they run in-line with the executable code, so they're in</span>
<span class="c1">## lowercase. (`try` and `start` are theoretically in that list, but explained</span>
<span class="c1">## elsewhere) Note: all of these (except start) don't need explicit curly</span>
<span class="c1">## braces `{` and `}`.</span>

<span class="c1">## `do` - (which you already saw) runs a block or a statement as a term.</span>
<span class="c1">## Normally you cannot use a statement as a value (or "term"). `do` helps us</span>
<span class="c1">## do it.</span>

<span class="c1"># my $value = if True { 1 } # this fails since `if` is a statement</span>
<span class="k">my</span> <span class="nv">$a</span> = <span class="k">do</span> <span class="k">if</span> <span class="nb">True</span> { <span class="mi">5</span> }    <span class="c1"># with `do`, `if` is now a term returning a value</span>

<span class="c1">## `once` - makes sure a piece of code only runs once.</span>
<span class="k">for</span> ^<span class="mi">5</span> {
    <span class="nb">once</span> <span class="nb">say</span> <span class="mi">1</span>
}; <span class="c1">#=&gt; 1, only prints ... once</span>

<span class="c1">## Similar to `state`, they're cloned per-scope.</span>
<span class="k">for</span> ^<span class="mi">5</span> {
    <span class="k">sub</span> { <span class="nb">once</span> <span class="nb">say</span> <span class="mi">1</span> }()
}; <span class="c1">#=&gt; 1 1 1 1 1, prints once per lexical scope.</span>

<span class="c1">## `gather` - co-routine thread. The `gather` constructs allows us to `take`</span>
<span class="c1">## several values from an array/list, much like `do`.</span>
<span class="nb">say</span> <span class="k">gather</span> <span class="k">for</span> ^<span class="mi">5</span> {
    <span class="k">take</span> <span class="nv">$_</span> * <span class="mi">3</span> - <span class="mi">1</span>;
    <span class="k">take</span> <span class="nv">$_</span> * <span class="mi">3</span> + <span class="mi">1</span>;
}
<span class="c1">#=&gt; -1 1 2 4 5 7 8 10 11 13</span>

<span class="nb">say</span> <span class="nb">join</span> <span class="s">','</span>, <span class="k">gather</span> <span class="k">if</span> <span class="nb">False</span> {
    <span class="k">take</span> <span class="mi">1</span>;
    <span class="k">take</span> <span class="mi">2</span>;
    <span class="k">take</span> <span class="mi">3</span>;
}
<span class="c1"># Doesn't print anything.</span>

<span class="c1">## `eager` - evaluates a statement eagerly (forces eager context)</span>
<span class="c1">## Don't try this at home:</span>
<span class="c1"># eager 1..*; # this will probably hang for a while (and might crash ...).</span>
<span class="c1">## But consider:</span>
<span class="k">constant</span> <span class="n">thrice</span> = <span class="k">gather</span> <span class="k">for</span> ^<span class="mi">3</span> { <span class="nb">say</span> <span class="k">take</span> <span class="nv">$_</span> }; <span class="c1"># Doesn't print anything</span>
<span class="c1">## versus:</span>
<span class="k">constant</span> <span class="n">thrice</span> = <span class="nb">eager</span> <span class="k">gather</span> <span class="k">for</span> ^<span class="mi">3</span> { <span class="nb">say</span> <span class="k">take</span> <span class="nv">$_</span> }; <span class="c1">#=&gt; 0 1 2</span>
</pre></div>
<h2>Iterables</h2>
<div class="highlight"><pre><span></span><span class="c1">## Iterables are objects that can be iterated over which are</span>
<span class="c1">## are similar to the `for` construct.</span>

<span class="c1">## `flat` - flattens iterables.</span>
<span class="nb">say</span> (<span class="mi">1</span>, <span class="mi">10</span>, (<span class="mi">20</span>, <span class="mi">10</span>) );      <span class="c1">#=&gt; (1 10 (20 10)),  notice how neste lists are</span>
                             <span class="c1"># preserved</span>
<span class="nb">say</span> (<span class="mi">1</span>, <span class="mi">10</span>, (<span class="mi">20</span>, <span class="mi">10</span>) ).<span class="n">flat</span>; <span class="c1">#=&gt; (1 10 20 10), now the iterable is flat</span>

<span class="c1">## - `lazy` - defers actual evaluation until value is fetched by forcing</span>
<span class="c1">## lazy context.</span>
<span class="k">my</span> <span class="nv">@lazy-array</span> = (<span class="mi">1</span><span class="o">..</span><span class="mi">100</span>).<span class="nb">lazy</span>;
<span class="nb">say</span> <span class="nv">@lazy-array</span>.<span class="n">is-lazy</span>; <span class="c1">#=&gt; True, check for laziness with the `is-lazy` method.</span>
<span class="nb">say</span> <span class="nv">@lazy-array</span>;         <span class="c1">#=&gt; [...] List has not been iterated on!</span>
<span class="k">my</span> <span class="nv">@lazy-array</span> { .<span class="nb">print</span> }; <span class="c1"># This works and will only do as much work as</span>
                           <span class="c1"># is needed.</span>

<span class="c1"># ( **TODO** explain that gather/take and map are all lazy)</span>

<span class="c1">## `sink` - an `eager` that discards the results by forcing sink context.</span>
<span class="k">constant</span> <span class="n">nilthingie</span> = <span class="n">sink</span> <span class="k">for</span> ^<span class="mi">3</span> { .<span class="nb">say</span> } <span class="c1">#=&gt; 0 1 2</span>
<span class="nb">say</span> <span class="n">nilthingie</span>.<span class="nb">perl</span>;                       <span class="c1">#=&gt; Nil</span>

<span class="c1">## `quietly` - suppresses warnings in blocks.</span>
<span class="n">quietly</span> { <span class="k">warn</span> <span class="s">'This is a warning!'</span> }; <span class="c1">#=&gt; No output</span>

<span class="c1">## `contend` - attempts side effects under STM</span>
<span class="c1">## Not yet implemented!</span>
</pre></div>
<h2>More operators thingies!</h2>
<div class="highlight"><pre><span></span><span class="c1">## Everybody loves operators! Let's get more of them.</span>

<span class="c1">## The precedence list can be found here:</span>
<span class="c1">## https://docs.perl6.org/language/operators#Operator_Precedence</span>
<span class="c1">## But first, we need a little explanation about associativity:</span>

<span class="c1">## Binary operators:</span>
<span class="nv">$a</span> ! <span class="nv">$b</span> ! <span class="nv">$c</span>; <span class="c1"># with a left-associative `!`, this is `($a ! $b) ! $c`</span>
<span class="nv">$a</span> ! <span class="nv">$b</span> ! <span class="nv">$c</span>; <span class="c1"># with a right-associative `!`, this is `$a ! ($b ! $c)`</span>
<span class="nv">$a</span> ! <span class="nv">$b</span> ! <span class="nv">$c</span>; <span class="c1"># with a non-associative `!`, this is illegal</span>
<span class="nv">$a</span> ! <span class="nv">$b</span> ! <span class="nv">$c</span>; <span class="c1"># with a chain-associative `!`, this is `($a ! $b) and ($b ! $c)`</span>
<span class="nv">$a</span> ! <span class="nv">$b</span> ! <span class="nv">$c</span>; <span class="c1"># with a list-associative `!`, this is `infix:&lt;&gt;`</span>

<span class="c1">## Unary operators:</span>
!<span class="nv">$a</span>! <span class="c1"># with left-associative `!`, this is `(!$a)!`</span>
!<span class="nv">$a</span>! <span class="c1"># with right-associative `!`, this is `!($a!)`</span>
!<span class="nv">$a</span>! <span class="c1"># with non-associative `!`, this is illegal</span>
</pre></div>
<h3>Create your own operators!</h3>
<div class="highlight"><pre><span></span><span class="c1">## Okay, you've been reading all of that, so you might want to try something</span>
<span class="c1">## more exciting?! I'll tell you a little secret (or not-so-secret):</span>
<span class="c1">## In Perl 6, all operators are actually just funny-looking subroutines.</span>

<span class="c1">## You can declare an operator just like you declare a sub:</span>
<span class="c1"># prefix refers to the operator categories (prefix, infix, postfix, etc).</span>
<span class="k">sub</span> <span class="n">prefix:</span><span class="s">&lt;win&gt;</span>( <span class="nv">$winner</span> ) {
    <span class="nb">say</span> <span class="s">"$winner Won!"</span>;
}
<span class="n">win</span> <span class="s">"The King"</span>; <span class="c1">#=&gt; The King Won!</span>
                <span class="c1"># (prefix means 'before')</span>

<span class="c1">## you can still call the sub with its "full name":</span>
<span class="nb">say</span> <span class="n">prefix:</span><span class="s">&lt;!&gt;(True);      #=&gt;</span> <span class="nb">False</span>
<span class="n">prefix:</span><span class="s">&lt;win&gt;</span>(<span class="s">"The Queen"</span>); <span class="c1">#=&gt; The Queen Won!</span>

<span class="k">sub</span> <span class="n">postfix:</span><span class="s">&lt;!&gt;( Int $n ) {</span>
<span class="s">    [*] 2..$n; # using the reduce meta-operator... See below ;-)!</span>
<span class="s">}</span>
<span class="s">say 5!; #=&gt;</span> <span class="mi">120</span>
        <span class="c1"># Postfix operators ('after') have to come *directly* after the term.</span>
        <span class="c1"># No whitespace. You can use parentheses to disambiguate, i.e. `(5!)!`</span>

<span class="k">sub</span> <span class="n">infix:</span><span class="s">&lt;times&gt;</span>( <span class="nb">Int</span> <span class="nv">$n</span>, <span class="nb">Block</span> <span class="nv">$r</span> ) { <span class="c1"># infix ('between')</span>
    <span class="k">for</span> ^<span class="nv">$n</span> {
        <span class="nv">$r</span>(); <span class="c1"># You need the explicit parentheses to call the function in `$r`,</span>
              <span class="c1"># else you'd be referring at the variable itself, like with `&amp;r`.</span>
    }
}
<span class="mi">3</span> <span class="nb">times</span> -&gt; { <span class="nb">say</span> <span class="s">"hello"</span> }; <span class="c1">#=&gt; hello</span>
                            <span class="c1">#=&gt; hello</span>
                            <span class="c1">#=&gt; hello</span>
<span class="c1">## It's recommended to put spaces around your</span>
<span class="c1">## infix operator calls.</span>

<span class="c1">## For circumfix and post-circumfix ones</span>
<span class="k">sub</span> <span class="n">circumfix:</span><span class="s">&lt;[ ]&gt;</span>( <span class="nb">Int</span> <span class="nv">$n</span> ) {
    <span class="nv">$n</span> ** <span class="nv">$n</span>
}
<span class="nb">say</span> [<span class="mi">5</span>]; <span class="c1">#=&gt; 3125</span>
         <span class="c1"># circumfix means 'around'. Again, no whitespace.</span>

<span class="k">sub</span> <span class="n">postcircumfix:</span><span class="s">&lt;{ }&gt;</span>( <span class="nb">Str</span> <span class="nv">$s</span>, <span class="nb">Int</span> <span class="nv">$idx</span> ) {
    <span class="c1">## post-circumfix is 'after a term, around something'</span>
    <span class="nv">$s</span>.<span class="nb">substr</span>(<span class="nv">$idx</span>, <span class="mi">1</span>);
}
<span class="nb">say</span> <span class="s">"abc"</span>{<span class="mi">1</span>}; <span class="c1">#=&gt; b</span>
              <span class="c1"># after the term `"abc"`, and around the index (1)</span>

<span class="c1">## This really means a lot -- because everything in Perl 6 uses this.</span>
<span class="c1">## For example, to delete a key from a hash, you use the `:delete` adverb</span>
<span class="c1">## (a simple named argument underneath):</span>
<span class="nv">%h</span>{<span class="nv">$key</span>}:<span class="n">delete</span>;
<span class="c1">## equivalent to:</span>
<span class="n">postcircumfix:</span><span class="s">&lt;{ }&gt;</span>( <span class="nv">%h</span>, <span class="nv">$key</span>, :<span class="n">delete</span> ); <span class="c1"># (you can call operators like this)</span>

<span class="c1">## It's *all* using the same building blocks! Syntactic categories</span>
<span class="c1">## (prefix infix ...), named arguments (adverbs), ..., etc. used to build</span>
<span class="c1">## the language - are available to you. Obviously, you're advised against</span>
<span class="c1">## making an operator out of *everything* -- with great power comes great</span>
<span class="c1">## responsibility.</span>
</pre></div>
<h3>Meta operators!</h3>
<div class="highlight"><pre><span></span><span class="c1">## Oh boy, get ready!. Get ready, because we're delving deep into the rabbit's</span>
<span class="c1">## hole, and you probably won't want to go back to other languages after</span>
<span class="c1">## reading this. (I'm guessing you don't want to go back at this point but</span>
<span class="c1">## let's continue, for the journey is long and enjoyable!).</span>

<span class="c1">## Meta-operators, as their name suggests, are *composed* operators.</span>
<span class="c1">## Basically, they're operators that act on another operators.</span>

<span class="c1">## The reduce meta-operator is a prefix meta-operator that takes a binary</span>
<span class="c1">## function and one or many lists. If it doesn't get passed any argument,</span>
<span class="c1">## it either returns a "default value" for this operator (a meaningless value)</span>
<span class="c1">## or `Any` if there's none (examples below). Otherwise, it pops an element</span>
<span class="c1">## from the list(s) one at a time, and applies the binary function to the last</span>
<span class="c1">## result (or the list's first element) and the popped element.</span>

<span class="c1">## To sum a list, you could use the reduce meta-operator with `+`, i.e.:</span>
<span class="nb">say</span> [+] <span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">3</span>; <span class="c1">#=&gt; 6, equivalent to (1+2)+3.</span>

<span class="c1">## To multiply a list</span>
<span class="nb">say</span> [*] <span class="mi">1</span><span class="o">..</span><span class="mi">5</span>; <span class="c1">#=&gt; 120, equivalent to ((((1*2)*3)*4)*5).</span>

<span class="c1">## You can reduce with any operator, not just with mathematical ones.</span>
<span class="c1">## For example, you could reduce with `//` to get first defined element</span>
<span class="c1">## of a list:</span>
<span class="nb">say</span> [//] <span class="n">Nil</span>, <span class="nb">Any</span>, <span class="nb">False</span>, <span class="mi">1</span>, <span class="mi">5</span>;  <span class="c1">#=&gt; False</span>
                                 <span class="c1"># (Falsey, but still defined)</span>
<span class="c1">## Or with relational operators, i.e., `&gt;` to check elements of a list</span>
<span class="c1">## are ordered accordingly:</span>
<span class="nb">say</span> <span class="nb">say</span> [&gt;] <span class="mi">234</span>, <span class="mi">156</span>, <span class="mi">6</span>, <span class="mi">3</span>, -<span class="mi">20</span>; <span class="c1">#=&gt; True</span>

<span class="c1">## Default value examples:</span>
<span class="nb">say</span> [*] (); <span class="c1">#=&gt; 1</span>
<span class="nb">say</span> [+] (); <span class="c1">#=&gt; 0</span>
            <span class="c1"># meaningless values, since N*1=N and N+0=N.</span>
<span class="nb">say</span> [//];   <span class="c1">#=&gt; (Any)</span>
            <span class="c1"># There's no "default value" for `//`.</span>

<span class="c1">## You can also call it with a function you made up, using double brackets:</span>
<span class="k">sub</span> <span class="n">add</span>(<span class="nv">$a</span>, <span class="nv">$b</span>) { <span class="nv">$a</span> + <span class="nv">$b</span> }
<span class="nb">say</span> [[<span class="nv">&amp;add</span>]] <span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">3</span>; <span class="c1">#=&gt; 6</span>

<span class="c1">## The zip meta-operator is an infix meta-operator that also can be used as a</span>
<span class="c1">## "normal" operator. It takes an optional binary function (by default, it</span>
<span class="c1">## just creates a pair), and will pop one value off of each array and call</span>
<span class="c1">## its binary function on these until it runs out of elements. It returns an</span>
<span class="c1">## array with all of these new elements.</span>
<span class="nb">say</span> (<span class="mi">1</span>, <span class="mi">2</span>) <span class="o">Z</span> (<span class="mi">3</span>, <span class="mi">4</span>); <span class="c1">#=&gt; ((1, 3), (2, 4)), since by default the function</span>
                     <span class="c1"># makes an array.</span>
<span class="nb">say</span> <span class="mi">1</span><span class="o">..</span><span class="mi">3</span> <span class="o">Z</span>+ <span class="mi">4</span><span class="o">..</span><span class="mi">6</span>;    <span class="c1">#=&gt; (5, 7, 9), using the custom infix:&lt;+&gt; function</span>

<span class="c1">## Since `Z` is list-associative (see the list above),</span>
<span class="c1">## you can use it on more than one list</span>
(<span class="nb">True</span>, <span class="nb">False</span>) <span class="o">Z</span>|| (<span class="nb">False</span>, <span class="nb">False</span>) <span class="o">Z</span>|| (<span class="nb">False</span>, <span class="nb">False</span>); <span class="c1"># (True, False)</span>

<span class="c1">## And, as it turns out, you can also use the reduce meta-operator with it:</span>
[<span class="o">Z</span>||] (<span class="nb">True</span>, <span class="nb">False</span>), (<span class="nb">False</span>, <span class="nb">False</span>), (<span class="nb">False</span>, <span class="nb">False</span>); <span class="c1"># (True, False)</span>


<span class="c1">## And to end the operator list:</span>

<span class="c1">## The sequence operator is one of Perl 6's most powerful features:</span>
<span class="c1">## it's composed of first, on the left, the list you want Perl 6 to deduce from</span>
<span class="c1">## (and might include a closure), and on the right, a value or the predicate</span>
<span class="c1">## that says when to stop (or a Whatever Star for a lazy infinite list).</span>

<span class="k">my</span> <span class="nv">@list</span> = <span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">3</span>..<span class="mf">.10</span>;     <span class="c1"># basic arithmetic sequence</span>
<span class="c1"># my @list = 1, 3, 6...10;   # this dies because Perl 6 can't figure out the end</span>
<span class="k">my</span> <span class="nv">@list</span> = <span class="mi">1</span>, <span class="mi">2</span>, <span class="mi">3</span>...^<span class="mi">10</span>;    <span class="c1"># as with ranges, you can exclude the last element</span>
                             <span class="c1"># (the iteration ends when the predicate matches).</span>
<span class="k">my</span> <span class="nv">@list</span> = <span class="mi">1</span>, <span class="mi">3</span>, <span class="mi">9</span>...* &gt; <span class="mi">30</span>; <span class="c1"># you can use a predicate (with the Whatever Star).</span>
<span class="k">my</span> <span class="nv">@list</span> = <span class="mi">1</span>, <span class="mi">3</span>, <span class="mi">9</span> ... { <span class="nv">$_</span> &gt; <span class="mi">30</span> }; <span class="c1"># (equivalent to the above</span>
                                    <span class="c1"># using a block here).</span>

<span class="k">my</span> <span class="nv">@fib</span> = <span class="mi">1</span>, <span class="mi">1</span>, *+* ... *;   <span class="c1"># lazy infinite list of fibonacci sequence,</span>
                             <span class="c1"># computed using a closure!</span>
<span class="k">my</span> <span class="nv">@fib</span> = <span class="mi">1</span>, <span class="mi">1</span>, -&gt; <span class="nv">$a</span>, <span class="nv">$b</span> { <span class="nv">$a</span> + <span class="nv">$b</span> } ... *; <span class="c1"># (equivalent to the above)</span>
<span class="k">my</span> <span class="nv">@fib</span> = <span class="mi">1</span>, <span class="mi">1</span>, { <span class="nv">$^a</span> + <span class="nv">$^b</span> } ... *;         <span class="c1"># (also equivalent to the above)</span>
<span class="c1">## $a and $b will always take the previous values, meaning here</span>
<span class="c1">## they'll start with $a = 1 and $b = 1 (values we set by hand),</span>
<span class="c1">## then $a = 1 and $b = 2 (result from previous $a+$b), and so on.</span>

<span class="nb">say</span> <span class="nv">@fib</span>[^<span class="mi">10</span>]; <span class="c1">#=&gt; 1 1 2 3 5 8 13 21 34 55</span>
               <span class="c1"># (using a range as the index)</span>
<span class="c1">## Note: as for ranges, once reified, elements aren't re-calculated.</span>
<span class="c1">## That's why `@primes[^100]` will take a long time the first time you print</span>
<span class="c1">## it, then will be instateneous.</span>
</pre></div>
<h2>Regular Expressions</h2>
<div class="highlight"><pre><span></span><span class="c1">## I'm sure a lot of you have been waiting for this one. Well, now that you know</span>
<span class="c1">## a good deal of Perl 6 already, we can get started. First off, you'll have to</span>
<span class="c1">## forget about "PCRE regexps" (perl-compatible regexps).</span>
<span class="c1">##</span>
<span class="c1">## IMPORTANT: Don't skip them because you know PCRE. They're different. Some</span>
<span class="c1">## things are the same (like `?`, `+`, and `*`), but sometimes the semantics</span>
<span class="c1">## change (`|`). Make sure you read carefully, because you might trip over a</span>
<span class="c1">## new behavior.</span>
<span class="c1">##</span>
<span class="c1">## Perl 6 has many features related to RegExps. After all, Rakudo parses itself.</span>
<span class="c1">## We're first going to look at the syntax itself, then talk about grammars</span>
<span class="c1">## (PEG-like), differences between `token`, `regex` and `rule` declarators,</span>
<span class="c1">## and some more. Side note: you still have access to PCRE regexps using the</span>
<span class="c1">## `:P5` modifier which we won't be discussing this in this tutorial, though.</span>
<span class="c1">##</span>
<span class="c1">## In essence, Perl 6 natively implements PEG ("Parsing Expression Grammars").</span>
<span class="c1">## The pecking order for ambiguous parses is determined by a multi-level</span>
<span class="c1">## tie-breaking test:</span>
<span class="c1">##  - Longest token matching: `foo\s+` beats `foo` (by 2 or more positions)</span>
<span class="c1">##  - Longest literal prefix: `food\w*` beats `foo\w*` (by 1)</span>
<span class="c1">##  - Declaration from most-derived to less derived grammars</span>
<span class="c1">##    (grammars are actually classes)</span>
<span class="c1">##  - Earliest declaration wins</span>
<span class="nb">say</span> <span class="o">so</span> <span class="s">'a'</span> ~~<span class="sr"> /a/</span>;   <span class="c1">#=&gt; True</span>
<span class="nb">say</span> <span class="o">so</span> <span class="s">'a'</span> ~~<span class="sr"> / a /</span>; <span class="c1">#=&gt; True, more readable with some spaces!</span>

<span class="c1">## In all our examples, we're going to use the smart-matching operator against</span>
<span class="c1">## a regexp. We're converting the result using `so` to a Boolean value because,</span>
<span class="c1">## in fact, it's returning a `Match` object. They know how to respond to list</span>
<span class="c1">## indexing, hash indexing, and return the matched string. The results of the</span>
<span class="c1">## match are available in the `$/` variable (implicitly lexically-scoped). You</span>
<span class="c1">## can also use the capture variables which start at 0: `$0`, `$1', `$2`...</span>
<span class="c1">##</span>
<span class="c1">## You can also note that `~~` does not perform start/end checking, meaning</span>
<span class="c1">## the regexp can be matched with just one character of the string. We'll</span>
<span class="c1">## explain later how you can do it.</span>

<span class="c1">## In Perl 6, you can have any alphanumeric as a literal, everything else has</span>
<span class="c1">## to be escaped by using a backslash or quotes.</span>
<span class="nb">say</span> <span class="o">so</span> <span class="s">'a|b'</span> ~~<span class="sr"> / a '|' b /</span>; <span class="c1">#=&gt; `True`, it wouldn't mean the same thing if</span>
                             <span class="c1"># `|` wasn't escaped.</span>
<span class="nb">say</span> <span class="o">so</span> <span class="s">'a|b'</span> ~~<span class="sr"> / a \| b /</span>;  <span class="c1">#=&gt; `True`, another way to escape it.</span>

<span class="c1">## The whitespace in a regexp is actually not significant, unless you use the</span>
<span class="c1">## `:s` (`:sigspace`, significant space) adverb.</span>
<span class="nb">say</span> <span class="o">so</span> <span class="s">'a b c'</span> ~~<span class="sr"> / a  b  c /</span>; <span class="c1">#=&gt; `False`, space is not significant here!</span>
<span class="nb">say</span> <span class="o">so</span> <span class="s">'a b c'</span> ~~<span class="sr"> /:s a b c /</span>; <span class="c1">#=&gt; `True`, we added the modifier `:s` here.</span>

<span class="c1">## If we use only one space between strings in a regex, Perl 6 will warn us:</span>
<span class="nb">say</span> <span class="o">so</span> <span class="s">'a b c'</span> ~~<span class="sr"> / a b c /</span>;   <span class="c1">#=&gt; `False`, with warning about space</span>
<span class="nb">say</span> <span class="o">so</span> <span class="s">'a b c'</span> ~~<span class="sr"> / a  b  c /</span>; <span class="c1">#=&gt; `False`</span>

<span class="c1">## Please use quotes or :s (:sigspace) modifier (or, to suppress this warning,</span>
<span class="c1">## omit the space, or otherwise change the spacing). To fix this and make the</span>
<span class="c1">## spaces less ambiguous, either use at least two spaces between strings</span>
<span class="c1">## or use the `:s` adverb.</span>

<span class="c1">## As we saw before, we can embed the `:s` inside the slash delimiters, but we</span>
<span class="c1">## can also put it outside of them if we specify `m` for 'match':</span>
<span class="nb">say</span> <span class="o">so</span> <span class="s">'a b c'</span> ~~ <span class="sr">m:s/a  b  c/</span>; <span class="c1">#=&gt; `True`</span>

<span class="c1">## By using `m` to specify 'match', we can also use delimiters other than</span>
<span class="c1">## slashes:</span>
<span class="nb">say</span> <span class="o">so</span> <span class="s">'abc'</span> ~~ <span class="sr">m{a  b  c}</span>;     <span class="c1">#=&gt; `True`</span>
<span class="nb">say</span> <span class="o">so</span> <span class="s">'abc'</span> ~~ <span class="sr">m[a  b  c]</span>;     <span class="c1">#=&gt; `True`</span>
<span class="c1"># m/.../ is equivalent to /.../</span>

<span class="c1">## Use the :i adverb to specify case insensitivity:</span>
<span class="nb">say</span> <span class="o">so</span> <span class="s">'ABC'</span> ~~ <span class="sr">m:i{a  b  c}</span>;   <span class="c1">#=&gt; `True`</span>

<span class="c1">## However, whitespace is important as for how modifiers are applied (</span>
<span class="c1">## (which you'll see just below) ...</span>

<span class="c1">## Quantifying - `?`, `+`, `*` and `**`.</span>
<span class="c1">## `?` - zero or one match</span>
<span class="o">so</span> <span class="s">'ac'</span> ~~<span class="sr"> / a  b  c /</span>;   <span class="c1">#=&gt; `False`</span>
<span class="o">so</span> <span class="s">'ac'</span> ~~<span class="sr"> / a  b?  c /</span>;  <span class="c1">#=&gt; `True`, the "b" matched 0 times.</span>
<span class="o">so</span> <span class="s">'abc'</span> ~~<span class="sr"> / a  b?  c /</span>; <span class="c1">#=&gt; `True`, the "b" matched 1 time.</span>

<span class="c1">## ...As you read before, whitespace is important because it determines which</span>
<span class="c1">## part of the regexp is the target of the modifier:</span>
<span class="o">so</span> <span class="s">'def'</span> ~~<span class="sr"> / a  b  c? /</span>; <span class="c1">#=&gt; `False`, only the `c` is optional</span>
<span class="o">so</span> <span class="s">'def'</span> ~~<span class="sr"> / a  b?  c /</span>; <span class="c1">#=&gt; `False`, whitespace is not significant</span>
<span class="o">so</span> <span class="s">'def'</span> ~~<span class="sr"> / 'abc'? /</span>;   <span class="c1">#=&gt; `True`, the whole "abc" group is optional</span>

<span class="c1">## Here (and below) the quantifier applies only to the `b`</span>

<span class="c1">## `+` - one or more matches</span>
<span class="o">so</span> <span class="s">'ac'</span> ~~<span class="sr"> / a  b+  c /</span>;     <span class="c1">#=&gt; `False`, `+` wants at least one matching</span>
<span class="o">so</span> <span class="s">'abc'</span> ~~<span class="sr"> / a  b+  c /</span>;    <span class="c1">#=&gt; `True`, one is enough</span>
<span class="o">so</span> <span class="s">'abbbbc'</span> ~~<span class="sr"> / a  b+  c /</span>; <span class="c1">#=&gt; `True`, matched 4 "b"s</span>

<span class="c1">## `*` - zero or more matches</span>
<span class="o">so</span> <span class="s">'ac'</span> ~~<span class="sr"> / a  b*  c /</span>;     <span class="c1">#=&gt; `True`, they're all optional.</span>
<span class="o">so</span> <span class="s">'abc'</span> ~~<span class="sr"> / a  b*  c /</span>;    <span class="c1">#=&gt; `True`</span>
<span class="o">so</span> <span class="s">'abbbbc'</span> ~~<span class="sr"> / a  b*  c /</span>; <span class="c1">#=&gt; `True`</span>
<span class="o">so</span> <span class="s">'aec'</span> ~~<span class="sr"> / a  b*  c /</span>;    <span class="c1">#=&gt; `False`. "b"(s) are optional, not replaceable.</span>

<span class="c1">## `**` - (Unbound) Quantifier</span>
<span class="c1">## If you squint hard enough, you might understand why exponentation is used</span>
<span class="c1">## for quantity.</span>
<span class="o">so</span> <span class="s">'abc'</span> ~~<span class="sr"> / a  b**1  c /</span>;         <span class="c1">#=&gt; `True`, (exactly one time)</span>
<span class="o">so</span> <span class="s">'abc'</span> ~~<span class="sr"> / a  b**1..3  c /</span>;      <span class="c1">#=&gt; `True`, (one to three times)</span>
<span class="o">so</span> <span class="s">'abbbc'</span> ~~<span class="sr"> / a  b**1..3  c /</span>;    <span class="c1">#=&gt; `True`</span>
<span class="o">so</span> <span class="s">'abbbbbbc'</span> ~~<span class="sr"> / a  b**1..3  c /</span>; <span class="c1">#=&gt; `False, (too much)</span>
<span class="o">so</span> <span class="s">'abbbbbbc'</span> ~~<span class="sr"> / a  b**3..*  c /</span>; <span class="c1">#=&gt; `True`, (infinite ranges are okay)</span>

<span class="c1">## `&lt;[]&gt;` - Character classes</span>
<span class="c1">## Character classes are the equivalent of PCRE's `[]` classes, but they use a</span>
<span class="c1">## more perl6-ish syntax:</span>
<span class="nb">say</span> <span class="s">'fooa'</span> ~~<span class="sr"> / f &lt;[ o a ]&gt;+ /</span>;  <span class="c1">#=&gt; 'fooa'</span>

<span class="c1">## You can use ranges:</span>
<span class="nb">say</span> <span class="s">'aeiou'</span> ~~<span class="sr"> / a &lt;[ e..w ]&gt; /</span>; <span class="c1">#=&gt; 'ae'</span>

<span class="c1">## Just like in normal regexes, if you want to use a special character, escape</span>
<span class="c1">## it (the last one is escaping a space which would be equivalent to using</span>
<span class="c1">## ' '):</span>
<span class="nb">say</span> <span class="s">'he-he !'</span> ~~<span class="sr"> / 'he-' &lt;[ a..z \! \  ]&gt; + /</span>; <span class="c1">#=&gt; 'he-he !'</span>

<span class="c1">## You'll get a warning if you put duplicate names (which has the nice effect</span>
<span class="c1">## of catching the raw quoting):</span>
<span class="s">'he he'</span> ~~<span class="sr"> / &lt;[ h e ' ' ]&gt; /</span>;
<span class="c1"># Warns "Repeated character (') unexpectedly found in character class"</span>

<span class="c1">## You can also negate character classes... (`&lt;-[]&gt;` equivalent to `[^]` in PCRE)</span>
<span class="o">so</span> <span class="s">'foo'</span> ~~<span class="sr"> / &lt;-[ f o ]&gt; + /</span>;             <span class="c1">#=&gt; False</span>

<span class="c1">## ... and compose them:</span>
<span class="o">so</span> <span class="s">'foo'</span> ~~<span class="sr"> / &lt;[ a..z ] - [ f o ]&gt; + /</span>;   <span class="c1">#=&gt; `False`, (any letter except f and o)</span>
<span class="o">so</span> <span class="s">'foo'</span> ~~<span class="sr"> / &lt;-[ a..z ] + [ f o ]&gt; + /</span>;  <span class="c1">#=&gt; `True`, (no letter except f and o)</span>
<span class="o">so</span> <span class="s">'foo!'</span> ~~<span class="sr"> / &lt;-[ a..z ] + [ f o ]&gt; + /</span>; <span class="c1">#=&gt; `True`, (the + doesn't replace the</span>
                                          <span class="c1"># left part)</span>
</pre></div>
<h3>Grouping and capturing</h3>
<div class="highlight"><pre><span></span><span class="c1">## Group: you can group parts of your regexp with `[]`. Unlike PCRE's `(?:)`,</span>
<span class="c1">## these groups are *not* captured.</span>
<span class="o">so</span> <span class="s">'abc'</span> ~~<span class="sr"> / a [ b ] c /</span>;  <span class="c1"># `True`. The grouping does pretty much nothing</span>
<span class="o">so</span> <span class="s">'foo012012bar'</span> ~~<span class="sr"> / foo [ '01' &lt;[0..9]&gt; ] + bar /</span>;

<span class="c1">## The previous line returns `True`. The regex matches "012" 1 or more time</span>
<span class="c1">## (achieved by the the `+` applied to the group).</span>

<span class="c1">## But this does not go far enough, because we can't actually get back what</span>
<span class="c1">## we matched.</span>

<span class="c1">## Capture: The results of a regexp can be *captured* by using parentheses.</span>
<span class="o">so</span> <span class="s">'fooABCABCbar'</span> ~~<span class="sr"> / foo ( 'A' &lt;[A..Z]&gt; 'C' ) + bar /</span>; <span class="c1"># `True`. (using `so`</span>
                                                         <span class="c1">#  here, `$/` below)</span>

<span class="c1">## So, starting with the grouping explanations.</span>
<span class="c1">## As we said before, our `Match` object is stored inside the `$/` variable:</span>
<span class="nb">say</span> <span class="vg">$/</span>;    <span class="c1"># Will either print some weird stuff or `Nil` if nothing matched.</span>

<span class="c1">## As we also said before, it has array indexing:</span>
<span class="nb">say</span> <span class="vg">$/</span>[<span class="mi">0</span>]; <span class="c1">#=&gt; ｢ABC｣ ｢ABC｣</span>
           <span class="c1"># These corner brackets are `Match` objects.</span>
           <span class="c1"># Here, we have an array of these.</span>
<span class="nb">say</span> <span class="nv">$0</span>;    <span class="c1"># The same as above.</span>

<span class="c1">## Our capture is `$0` because it's the first and only one capture in the</span>
<span class="c1">## regexp. You might be wondering why it's an array, and the answer is simple:</span>
<span class="c1">## Some captures (indexed using `$0`, `$/[0]` or a named one) will be an array</span>
<span class="c1">## if and only if they can have more than one element. Thus any capture with</span>
<span class="c1">## `*`, `+` and `**` (whatever the operands), but not with `?`.</span>
<span class="c1">## Let's use examples to see that:</span>

<span class="c1">## Note: We quoted A B C to demonstrate that the whitespace between them isn't</span>
<span class="c1">##       significant. If we want the whitespace to *be* significant there, we</span>
<span class="c1">##       can use the :sigspace modifier.</span>
<span class="nb">say</span> <span class="o">so</span> <span class="s">'fooABCbar'</span> ~~<span class="sr"> / foo ( "A" "B" "C" )? bar /</span>; <span class="c1">#=&gt; `True`</span>
<span class="nb">say</span> <span class="vg">$/</span>[<span class="mi">0</span>];   <span class="c1">#=&gt; ｢ABC｣</span>
<span class="nb">say</span> <span class="nv">$0</span>.<span class="nb">WHAT</span>; <span class="c1">#=&gt; (Match)</span>
             <span class="c1"># There can't be more than one, so it's only a single match object.</span>
<span class="nb">say</span> <span class="o">so</span> <span class="s">'foobar'</span> ~~<span class="sr"> / foo ( "A" "B" "C" )? bar /</span>;    <span class="c1">#=&gt; True</span>
<span class="nb">say</span> <span class="nv">$0</span>.<span class="nb">WHAT</span>; <span class="c1">#=&gt; (Any)</span>
             <span class="c1"># This capture did not match, so it's empty</span>
<span class="o">so</span> <span class="s">'foobar'</span> ~~<span class="sr"> / foo ( "A" "B" "C" ) ** 0..1 bar /</span>; <span class="c1">#=&gt; `True`</span>
<span class="nb">say</span> <span class="nv">$0</span>.<span class="nb">WHAT</span>; <span class="c1">#=&gt; (Array)</span>
             <span class="c1"># A specific quantifier will always capture an Array,</span>
             <span class="c1"># be a range or a specific value (even 1).</span>

<span class="c1">## The captures are indexed per nesting. This means a group in a group will be</span>
<span class="c1">## nested under its parent group: `$/[0][0]`, for this code:</span>
<span class="s">'hello-~-world'</span> ~~<span class="sr"> / ( 'hello' ( &lt;[ \- \~ ]&gt; + ) ) 'world' /</span>;
<span class="nb">say</span> <span class="vg">$/</span>[<span class="mi">0</span>].<span class="nb">Str</span>;    <span class="c1">#=&gt; hello~</span>
<span class="nb">say</span> <span class="vg">$/</span>[<span class="mi">0</span>][<span class="mi">0</span>].<span class="nb">Str</span>; <span class="c1">#=&gt; ~</span>

<span class="c1">## This stems from a very simple fact: `$/` does not contain strings, integers</span>
<span class="c1">## or arrays, it only contains Match objects. These contain the `.list`, `.hash`</span>
<span class="c1">## and `.Str` methods but you can also just use `match&lt;key&gt;` for hash access</span>
<span class="c1">## and `match[idx]` for array access.</span>
<span class="nb">say</span> <span class="vg">$/</span>[<span class="mi">0</span>].<span class="n">list</span>.<span class="nb">perl</span>; <span class="c1">#=&gt; (Match.new(...),).list</span>
                     <span class="c1"># We can see it's a list of Match objects. These contain</span>
                     <span class="c1"># a bunch of info: where the match started/ended,</span>
                     <span class="c1"># the "ast" (see actions later), etc.</span>
                     <span class="c1"># You'll see named capture below with grammars.</span>

<span class="c1">## Alternation - the `or` of regexps</span>
<span class="c1">## WARNING: They are DIFFERENT from PCRE regexps.</span>
<span class="nb">say</span> <span class="o">so</span> <span class="s">'abc'</span> ~~<span class="sr"> / a [ b | y ] c /</span>; <span class="c1">#=&gt; `True`. Either "b" or "y".</span>
<span class="nb">say</span> <span class="o">so</span> <span class="s">'ayc'</span> ~~<span class="sr"> / a [ b | y ] c /</span>; <span class="c1">#=&gt; `True`. Obviously enough...</span>

<span class="c1">## The difference between this `|` and the one you're used to is</span>
<span class="c1">## LTM ("Longest Token Matching"). This means that the engine will always</span>
<span class="c1">## try to match as much as possible in the string.</span>
<span class="nb">say</span> <span class="s">'foo'</span> ~~<span class="sr"> / fo | foo /</span>; <span class="c1">#=&gt; `foo`, instead of `fo`, because it's longer.</span>

<span class="c1">## To decide which part is the "longest", it first splits the regex in</span>
<span class="c1">## two parts:</span>
<span class="c1">## The "declarative prefix" (the part that can be statically analyzed)</span>
<span class="c1">## and the procedural parts:</span>
<span class="c1">## - The declarative prefixes include alternations (`|`), conjunctions (`&amp;`),</span>
<span class="c1">## sub-rule calls (not yet introduced), literals, characters classes and</span>
<span class="c1">## quantifiers.</span>
<span class="c1">## - The procedural part include everything else: back-references,</span>
<span class="c1">## code assertions, and other things that can't traditionnaly be represented</span>
<span class="c1">## by normal regexps.</span>
<span class="c1">##</span>
<span class="c1">## Then, all the alternatives are tried at once, and the longest wins.</span>
<span class="c1">## Examples:</span>
<span class="c1">## DECLARATIVE | PROCEDURAL</span>
/ <span class="s">'foo'</span> \<span class="n">d</span>+     [ <span class="s">&lt;subrule1&gt;</span> || <span class="s">&lt;subrule2&gt;</span> ] /;
<span class="c1">## DECLARATIVE (nested groups are not a problem)</span>
/ \<span class="o">s</span>* [ \<span class="n">w</span> &amp; <span class="n">b</span> ] [ <span class="n">c</span> | <span class="n">d</span> ] /;
<span class="c1">## However, closures and recursion (of named regexps) are procedural.</span>
<span class="c1">## There are also more complicated rules, like specificity (literals win over</span>
<span class="c1">## character classes).</span>

<span class="c1">## Note: the first-matching `or` still exists, but is now spelled `||`</span>
<span class="nb">say</span> <span class="s">'foo'</span> ~~<span class="sr"> / fo || foo /</span>; <span class="c1">#=&gt; `fo` now.</span>
</pre></div>
<h2>Extra: the MAIN subroutine</h2>
<div class="highlight"><pre><span></span><span class="c1">## The `MAIN` subroutine is called when you run a Perl 6 file directly. It's</span>
<span class="c1">## very powerful, because Perl 6 actually parses the arguments and pass them</span>
<span class="c1">## as such to the sub. It also handles named argument (`--foo`) and will even</span>
<span class="c1">## go as far as to autogenerate a `--help` flag.</span>
<span class="k">sub</span> <span class="n">MAIN</span>(<span class="nv">$name</span>) {
    <span class="nb">say</span> <span class="s">"Hello, $name!"</span>;
}
<span class="c1">## This produces:</span>
<span class="c1">## $ perl6 cli.pl</span>
<span class="c1">## Usage:</span>
<span class="c1">##  t.pl &lt;name&gt;</span>

<span class="c1">## And since it's a regular Perl 6 sub, you can have multi-dispatch:</span>
<span class="c1">## (using a "Bool" for the named argument so that we can do `--replace`</span>
<span class="c1">## instead of `--replace=1`. The presence of `--replace` indicates truthness</span>
<span class="c1">## while its absence falseness).</span>

<span class="k">subset</span> <span class="n">File</span> <span class="k">of</span> <span class="nb">Str</span> <span class="k">where</span> *.<span class="nb">IO</span>.<span class="n">d</span>; <span class="c1"># convert to IO object to check the file exists</span>

<span class="k">multi</span> <span class="n">MAIN</span>(<span class="s">'add'</span>, <span class="nv">$key</span>, <span class="nv">$value</span>, <span class="nb">Bool</span> :<span class="nv">$replace</span>) { ... }
<span class="k">multi</span> <span class="n">MAIN</span>(<span class="s">'remove'</span>, <span class="nv">$key</span>) { ... }
<span class="k">multi</span> <span class="n">MAIN</span>(<span class="s">'import'</span>, <span class="n">File</span>, <span class="nb">Str</span> :<span class="nv">$as</span>) { ... } <span class="c1"># omitting parameter name</span>

<span class="c1">## This produces:</span>
<span class="c1">## $ perl6 cli.pl</span>
<span class="c1">## Usage:</span>
<span class="c1">##   cli.p6 [--replace] add &lt;key&gt; &lt;value&gt;</span>
<span class="c1">##   cli.p6 remove &lt;key&gt;</span>
<span class="c1">##   cli.p6 [--as=&lt;Str&gt;] import &lt;File&gt;</span>

<span class="c1">## As you can see, this is *very* powerful. It even went as far as to show inline</span>
<span class="c1">## the constants (the type is only displayed if the argument is `$`/is named).</span>
</pre></div>
<h2>APPENDIX A:</h2>

<h3>List of things</h3>
<div class="highlight"><pre><span></span><span class="c1">## It's assumed by now you know the Perl6 basics. This section is just here to</span>
<span class="c1">## list some common operations, but which are not in the "main part" of the</span>
<span class="c1">## tutorial to avoid bloating it up.</span>

<span class="c1">## Operators</span>

<span class="c1">## Sort comparison - they return one value of the `Order` enum: `Less`, `Same`</span>
<span class="c1">## and `More` (which numerify to -1, 0 or +1 respectively).</span>
<span class="mi">1</span> &lt;=&gt; <span class="mi">4</span>;                         <span class="c1"># sort comparison for numerics</span>
<span class="s">'a'</span> <span class="o">leg</span> <span class="s">'b'</span>;                     <span class="c1"># sort comparison for string</span>
<span class="nv">$obj</span> <span class="o">eqv</span> <span class="nv">$obj2</span>;                  <span class="c1"># sort comparison using eqv semantics</span>

<span class="c1">## Generic ordering</span>
<span class="mi">3</span> <span class="o">before</span> <span class="mi">4</span>;                      <span class="c1"># True</span>
<span class="s">'b'</span> <span class="o">after</span> <span class="s">'a'</span>;                   <span class="c1"># True</span>

<span class="c1">## Short-circuit default operator - similar to `or` and `||`, but instead</span>
<span class="c1">## returns the first *defined* value:</span>
<span class="nb">say</span> <span class="nb">Any</span> // <span class="n">Nil</span> // <span class="mi">0</span> // <span class="mi">5</span>;        <span class="c1">#=&gt; 0</span>

<span class="c1">## Short-circuit exclusive or (XOR) - returns `True` if one (and only one) of</span>
<span class="c1">## its arguments is true</span>
<span class="nb">say</span> <span class="nb">True</span> ^^ <span class="nb">False</span>;               <span class="c1">#=&gt; True</span>

<span class="c1">## Flip flops - these operators (`ff` and `fff`, equivalent to P5's `..`</span>
<span class="c1">## and `...`) are operators that take two predicates to test: They are `False`</span>
<span class="c1">## until their left side returns `True`, then are `True` until their right</span>
<span class="c1">## side returns `True`. Similar to ranges, you can exclude the iteration when</span>
<span class="c1">## it become `True`/`False` by using `^` on either side. Let's start with an</span>
<span class="c1">## example :</span>
<span class="k">for</span> <span class="s">&lt;well met young hero we shall meet later&gt;</span> {
    <span class="c1"># by default, `ff`/`fff` smart-match (`~~`) against `$_`:</span>
    <span class="k">if</span> <span class="s">'met'</span> ^<span class="o">ff</span> <span class="s">'meet'</span> { <span class="c1"># Won't enter the if for "met"</span>
        .<span class="nb">say</span>              <span class="c1"># (explained in details below).</span>
    }

    <span class="k">if</span> <span class="nb">rand</span> == <span class="mi">0</span> <span class="o">ff</span> <span class="nb">rand</span> == <span class="mi">1</span> { <span class="c1"># compare variables other than `$_`</span>
        <span class="nb">say</span> <span class="s">"This ... probably will never run ..."</span>;
    }
}

<span class="c1">## This will print "young hero we shall meet" (excluding "met"): the flip-flop</span>
<span class="c1">## will start returning `True` when it first encounters "met" (but will still</span>
<span class="c1">## return `False` for "met" itself, due to the leading `^` on `ff`), until it</span>
<span class="c1">## sees "meet", which is when it'll start returning `False`.</span>

<span class="c1">## The difference between `ff` (awk-style) and `fff` (sed-style) is that `ff`</span>
<span class="c1">## will test its right side right when its left side changes to `True`, and can</span>
<span class="c1">## get back to `False` right away (*except* it'll be `True` for the iteration</span>
<span class="c1">## that matched) while `fff` will wait for the next iteration to try its right</span>
<span class="c1">## side, once its left side changed:</span>
.<span class="nb">say</span> <span class="k">if</span> <span class="s">'B'</span> <span class="o">ff</span> <span class="s">'B'</span> <span class="k">for</span> <span class="s">&lt;A B C B A&gt;</span>; <span class="c1">#=&gt; B B</span>
                                    <span class="c1"># because the right-hand-side was tested</span>
                                    <span class="c1"># directly (and returned `True`).</span>
                                    <span class="c1"># "B"s are printed since it matched that</span>
                                    <span class="c1"># time (it just went back to `False`</span>
                                    <span class="c1"># right away).</span>
.<span class="nb">say</span> <span class="k">if</span> <span class="s">'B'</span> <span class="o">fff</span> <span class="s">'B'</span> <span class="k">for</span> <span class="s">&lt;A B C B A&gt;</span>; <span class="c1">#=&gt; B C B</span>
                                    <span class="c1"># The right-hand-side wasn't tested until</span>
                                    <span class="c1">#  `$_` became "C"</span>
                                    <span class="c1"># (and thus did not match instantly).</span>

<span class="c1">## A flip-flop can change state as many times as needed:</span>
<span class="k">for</span> <span class="s">&lt;test start print it stop not printing start print again stop not anymore&gt;</span> {
    .<span class="nb">say</span> <span class="k">if</span> <span class="nv">$_</span> <span class="o">eq</span> <span class="s">'start'</span> ^<span class="o">ff</span>^ <span class="nv">$_</span> <span class="o">eq</span> <span class="s">'stop'</span>; <span class="c1"># exclude both "start" and "stop",</span>
                                             <span class="c1">#=&gt; "print it print again"</span>
}

<span class="c1">## You might also use a Whatever Star, which is equivalent to `True` for the</span>
<span class="c1">## left side or `False` for the right:</span>
<span class="k">for</span> (<span class="mi">1</span>, <span class="mi">3</span>, <span class="mi">60</span>, <span class="mi">3</span>, <span class="mi">40</span>, <span class="mi">60</span>) { <span class="c1"># Note: the parenthesis are superfluous here</span>
                            <span class="c1"># (sometimes called "superstitious parentheses")</span>
    .<span class="nb">say</span> <span class="k">if</span> <span class="nv">$_</span> &gt; <span class="mi">50</span> <span class="o">ff</span> *;   <span class="c1"># Once the flip-flop reaches a number greater</span>
                            <span class="c1"># than 50, it'll never go back to `False`</span>
                            <span class="c1">#=&gt; 60 3 40 60</span>
}

<span class="c1">## You can also use this property to create an `if` that'll not go through the</span>
<span class="c1">## first time:</span>
<span class="k">for</span> <span class="s">&lt;a b c&gt;</span> {
    .<span class="nb">say</span> <span class="k">if</span> * ^<span class="o">ff</span> *; <span class="c1"># the flip-flop is `True` and never goes back to `False`,</span>
                     <span class="c1">#  but the `^` makes it *not run* on the first iteration</span>
                     <span class="c1">#=&gt; b c</span>
}

<span class="c1">## The `===` operator is the value identity operator and uses `.WHICH` on the</span>
<span class="c1">## objects to compare them  while `=:=` is the container identity operator</span>
<span class="c1">## and uses `VAR()` on the objects to compare them.</span>
</pre></div>
<p>If you want to go further, you can:</p>

<ul>
<li>Read the <a href="https://docs.perl6.org/">Perl 6 Docs</a>. This is a great
resource on Perl6. If you are looking for something, use the search bar.
This will give you a dropdown menu of all the pages referencing your search
term (Much better than using Google to find Perl 6 documents!).</li>
<li>Read the <a href="http://perl6advent.wordpress.com/">Perl 6 Advent Calendar</a>. This
is a great source of Perl 6 snippets and explanations. If the docs don’t
describe something well enough, you may find more detailed information here.
This information may be a bit older but there are many great examples and
explanations. Posts stopped at the end of 2015 when the language was declared
stable and Perl 6.c was released.</li>
<li>Come along on <code>#perl6</code> at <code>irc.freenode.net</code>. The folks here are
always helpful.</li>
<li>Check the <a href="https://github.com/rakudo/rakudo/tree/nom/src/core">source of Perl 6’s functions and
classes</a>. Rakudo is
mainly written in Perl 6 (with a lot of NQP, “Not Quite Perl”, a Perl 6 subset
easier to implement and optimize).</li>
<li>Read <a href="http://design.perl6.org/">the language design documents</a>. They explain
P6 from an implementor point-of-view, but it’s still very interesting.</li>
</ul>

    <hr>
    <p>Got a suggestion? A correction, perhaps? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Open an Issue</a> on the Github Repo, or make a <a href="https://github.com/adambard/learnxinyminutes-docs/edit/master/perl6.html.markdown">pull request</a> yourself!
    </p>
    <p class="contributed">
    Originally contributed by vendethiel, and updated by <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/perl6.html.markdown">14 contributor(s)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="Learn-perl6-in-Y-Minutes_fichiers/88x31.png"></a>
    <p>
    © 2019
        <a href="http://github.com/vendethiel">vendethiel</a>,
        <a href="https://cry.nu/">Samantha McVey</a>
    </p>

    <p>

    </p></footer>
  </div>

        </div>

        <script src="Learn-perl6-in-Y-Minutes_fichiers/jquery.js"></script>
        <script src="Learn-perl6-in-Y-Minutes_fichiers/script.js"></script>

        <script>
            var _gaq=[['_setAccount','UA-3525624-21'],['_trackPageview']];
            (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
            g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
            s.parentNode.insertBefore(g,s)}(document,'script'));
        </script>
    

</body></html>